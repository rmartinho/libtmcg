This is libTMCG.info, produced by makeinfo version 5.2 from
libTMCG.texi.

This is the reference manual of LibTMCG.

   Revision 20151224.

   Copyright © 2005, 2006, 2007, 2009, 2015 Heiko Stamer
<<HeikoStamer@gmx.net>>.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".


File: libTMCG.info,  Node: Top,  Next: Introduction,  Up: (dir)

LibTMCG Reference Manual
************************

* Menu:

* Introduction::
* Application Programming Interface::
* Examples::
* Licenses::
* General and API Index::

This is the reference manual of LibTMCG.

   Revision 20151224.

   Copyright © 2005, 2006, 2007, 2009, 2015 Heiko Stamer
<<HeikoStamer@gmx.net>>.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".


File: libTMCG.info,  Node: Introduction,  Next: Application Programming Interface,  Prev: Top,  Up: Top

1 Introduction
**************

'LibTMCG' is a C++ library for creating secure and fair online card
games.  The library contains a sort of useful classes, algorithms, and
high-level protocols to support an application programmer in writing
such software.  The most remarkable feature is the absence of a trusted
third party (TTP), i.e., neither a central game server nor trusted
hardware components are necessary.  Thus, with the present library there
is no need for an independent referee, because the applied protocols
provide a basic level of confidentiality and fairness by itself.
Consequently, the library is well-suited for peer-to-peer (P2P)
environments where no TTP is available.  Of course, we cannot avoid that
malicious players share information about their private cards, but the
protocols ensure that the shuffle of the deck is performed randomly
(presumed that at least one player is honest) and thus the cards will be
distributed uniformly among the players.  Further, no coalition can
learn the private cards of a player against his will (except for trivial
conclusions).  The corresponding cryptographic problem, actually called
"Mental Poker", has been studied since 1979 (Shamir, Rivest, and
Adleman) by many authors.  LibTMCG provides the first practical
implementation of such protocols.

   The security and the fairness rely on advanced cryptographic
techniques--the so-called zero-knowledge proofs.  Using these 'building
blocks' the high-level protocols minimize the effect of coalitions and
preserve the confidentiality of the players' strategy, i.e., the players
are not required to reveal their cards at the end of the game to show
that they did not cheat.  This important property is often required in
card games like Poker.

   LibTMCG is _Free Software_ according to the definition of the Free
Software Foundation.  The source code is released under the GNU _General
Public License_ Version 2.

* Menu:

* Further Reading::
* Getting Started::
* Preliminaries::
* Preparation::
* Header Files and Name Spaces::
* Building Sources::
* Initializing the Library::


File: libTMCG.info,  Node: Further Reading,  Next: Getting Started,  Up: Introduction

1.1 Further Reading
===================

The cryptographic background and a detailed discussion of the
implementation issues are beyond the scope of this manual.  The
interested reader is referred to the following papers:
     [Sc98]: CHRISTIAN SCHINDELHAUER. 	_Toolbox for Mental Card Games._
     Technical Report A-98-14, University of Lübeck, 1998.
     <http://citeseer.ist.psu.edu/schindelhauer98toolbox.html>
     [BS03]: ADAM BARNETT and NIGEL P. SMART. 	_Mental Poker Revisited._
     In K.G. Paterson (Ed.): Cryptography and Coding 2003,	Lecture Notes
     in Computer Science 2898, pp.  370-383, 2003.
     [Gr05]: JENS GROTH. 	_A Verifiable Secret Shuffle of Homomorphic
     Encryptions._
     Cryptology ePrint Archive, Report 2005/246, 2005.
     <http://eprint.iacr.org/2005/246>
     [Gr10]: JENS GROTH. 	_A Verifiable Secret Shuffle of Homomorphic
     Encryptions._
     Journal of Cryptology, Volume 23 Issue 4, pp.  546-579, 2010.
     <http://dx.doi.org/10.1007/s00145-010-9067-9>
     [HSSV09]: SEBASTIAAN DE HOOGH, BERRY SCHOENMAKERS, BORIS SKORIC,
     and JOSE VILLEGAS. 	_Verifiable Rotation of Homomorphic
     Encryptions_
     Public Key Cryptography 2009, Lecture Notes in Computer Science
     5443, pp.  393-410, 2009.
     <http://dx.doi.org/10.1007/978-3-642-00468-1_22>
     [St04]: HEIKO STAMER. 	_Kryptographische Skatrunde._  (in German)
     Offene Systeme (ISSN 1619-0114), 4:10-30, 2004.
     <http://www.nongnu.org/libtmcg/OS-4-2004-openskat_rev2005.pdf>
     [St05]: HEIKO STAMER. 	_Efficient Electronic Gambling: An Extended
     Implementation	of the Toolbox for Mental Card Games._
     Proceedings of the Western European Workshop on Research in
     Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,	pp.
     1-12, 2005.
     <http://www.nongnu.org/libtmcg/WEWoRC2005_proc.pdf>


File: libTMCG.info,  Node: Getting Started,  Next: Preliminaries,  Prev: Further Reading,  Up: Introduction

1.2 Getting Started
===================

This manual describes the application programming interface of LibTMCG.
All relevant data types, public classes and security parameters are
explained.  The reader should have an advanced knowledge in applied
cryptography and C++ programming.  Reference is made at this point to
the famous 'Handbook of Applied Cryptography' for a brief introduction
of this topic.

   This document follows, in style and rarely in phrasing, the
'Reference Manual of the GNU Crypto Library'.  Thus don't be surprised,
if you recognize some obvious analogies.


File: libTMCG.info,  Node: Preliminaries,  Next: Preparation,  Prev: Getting Started,  Up: Introduction

1.3 Preliminaries
=================

The most card games are played with a regular card deck, i.e., cards
where the pattern on the front side (face) determines the card type
(e.g.  the King of Spades, the Seven of Hearts, the Ace of Club, or the
Jack of Diamonds) and where the back sides of all cards are
indistinguishable.  Only such 'regular' card decks are supported by
LibTMCG.

* Menu:

* Terminology::
* Security::


File: libTMCG.info,  Node: Terminology,  Next: Security,  Up: Preliminaries

1.3.1 Terminology
-----------------

The following list defines some common terms that are subsequently used
in the manual.

     Player: A _player_ is an active participant in an electronic card
     game.

     Observer: An _observer_ is an passive party who watches the	game.

     Card: The term _card_ means the electronic representation of a
     playing	card.

     Card Type: The _card type_ is a nonnegative integer which
     corresponds	to the pattern on the picture side of a real playing
     card.  We	assume here that such a natural encoding always exists.

     Masking: _Masking_ is a process which aim is to transform the card
     representation such that the input card and the result cannot	be
     linked (except for trivial conclusions).  Roughly speaking, masking
     is the (re-)encryption of a card representation such that the
     original card type is preserved.

     Card Secret: The _card secret_ contains all random values used in a
     masking	operation.  These values must be kept secret until the card
     is	publicly revealed.  Otherwise the corresponding output of the
     masking	transformation is linkable and other players may learn the
     card type.

     Open Card: An _open card_ is a card whose type can be easily
     determined by all players and usually by observers as well.

     Masked Card: A _masked card_ (also known as face-down card) is a
     card whose	type is unknown to a subset of players.  It can be only
     revealed, if	all players cooperate in a common computation of the
     type.

     Private Card: A _private card_ is a card whose type is only known
     to its	owner.  As long as the owner does not corporate the type of
     the	private card stays hidden to all other players (except for
     trivial	conclusions).

     Stack: A _stack_ is a not necessarily disjoint subset of the whole
     card deck.

     Prover and Verifier: The _prover_ is a player who shows some
     property to another	party called _verifier_.  For example, he wants
     to show that	a masking operation was performed correctly, i.e., the
     card type	is preserved by the transformation.


File: libTMCG.info,  Node: Security,  Prev: Terminology,  Up: Preliminaries

1.3.2 Security
--------------

"Mental Poker" solutions cannot prevent that malicious players exchange
private information, for example, by telephone or Internet chat.
Cryptographic protocols can only minimize the effect of such colluding
parties and should try to protect the confidentiality for honest
players.  But even this small protection often relies on
number-theoretical assumptions which are only believed to be true, i.e.,
problems like factoring products of large primes or computing discrete
logarithms are only believed to be hard.  That means, strict
mathematical proofs(1) for the hardness of these problems are not known,
and it is not very likely that such proofs will ever be found.  However,
almost all public key cryptosystems rely on such assumptions and
therefore you should not care about this issue, as long as reasonable
security parameters are chosen.

   LibTMCG was designed to provide security in the "honest-but-curious"
(aka semi-honest) adversary model.  That means, all participants follow
the protocol instructions properly but they may gather information and
share them within a coalition to obtain a game advantage.  Thus we are
not concerned with robustness and availability issues which are hard to
solve in asynchronous environments like the Internet.  However, the most
operations are verifiable such that cheating can be detected.  To obtain
this verifiability, the protocols deploy so-called zero-knowledge proofs
which yield no further knowledge but the validity of a statement.  The
soundness error of these proofs is bounded by a security parameter t.
Depending on your application scenario this parameter should be chosen
such that there is a reasonable tradeoff between the cheating
probability (which is less or equal than 2^{-t}) and the produced
computational and communication complexity.

   Unfortunately, in practice there is a substantial problem with the
detection of cheaters.  Reliable cheater detection requires that an
authenticated broadcast channel has been established, where all players
have read/write access.  LibTMCG does not yet contain the necessary
protocols (reliable broadcast or even atomic broadcast) for creating
such a channel.  Thus you should take into account that not necessarily
the player acting as prover is the source of evil, if a verification
procedure fails.  This level of uncertainty is also a reason for our
restricted adversary model.

   Note that it is not known, whether the used protocols retain their
zero-knowledge property, if they are composed and executed in a
concurrent setting.  Thus the application programmer should be careful
and avoid parallel protocol sessions.  It is an open research project to
create a protocol suite whose security can be proven in the UC-framework
of Canetti (see _Universally Composable Security: A New Paradigm for
Cryptographic Protocols_, Cryptology ePrint Archive: Report 2000/067).
Furthermore, the protocols should employ concurrent zero-knowledge
proofs (see Dwork, Naor, Sahai: _Concurrent Zero-Knowledge_, Journal of
the ACM 51(6):851-898, 2004).

   LibTMCG was carefully implemented with respect to timing attacks (see
Kocher: _Cryptanalysis of Diffie-Hellman, RSA, DSS, and other
cryptosystems using timing attacks_, CRYPTO '95, LNCS 963, 1995).
Therefore we loose some efficiency, e.g., during modular
exponentiations.  However, it is strongly recommended to leave the
timing attack protection turned on, unless you know exactly where it is
really not needed.

     Security Advice: We have implemented all cryptographic primitives
     according to the cited research papers and to the best of our
     knowledge.  However, we can not eliminate any possibility of
     contained flaws or bugs, because the implementation of such complex
     protocols is always an error-prone process.  Thus we encourage
     readers with advanced cryptographic background to review the source
     code of LibTMCG. Please report any complaint or correction
     proposal.

   ---------- Footnotes ----------

   (1) For instance, a "tight reduction" to a known hard problem in the
sense of complexity theory.


File: libTMCG.info,  Node: Preparation,  Next: Header Files and Name Spaces,  Prev: Preliminaries,  Up: Introduction

1.4 Preparation
===============

LibTMCG depends on three other basic libraries.  Therefore you will need
the corresponding development files to build LibTMCG and your
application properly.  The following list gives a short exposition of
the used features and specifies the required versions:
   * GNU Multiple Precision Arithmetic Library ('libgmp'),
     Version \ge 4.1.0

     The library provides a powerful framework for performing	arbitrary
     precision arithmetic on integers.  Further reasons	for choosing
     this dependency are the license compatibility,	the portability, the
     vital maintenance, and of course, the	reasonable performance.

   * GNU Crypto Library ('libgcrypt'),	Version \ge 1.2.0

     The library provides some basic cryptographic algorithms	(e.g.
     RIPEMD-160) and an easily accessible interface for
     cryptographically strong pseudo random numbers.

   * GNU Privacy Guard Error Code Library ('libgpg-error'),
     Version \ge 0.5

     This library defines common error values, e.g., returned by the	GNU
     Crypto Library.
   We suppose that the reader is familiar with these libraries because
their correct installation, configuration, and usage is crucial to the
security of the entire application.


File: libTMCG.info,  Node: Header Files and Name Spaces,  Next: Building Sources,  Prev: Preparation,  Up: Introduction

1.5 Header Files and Name Spaces
================================

The interface definitions of classes, data types, and security
parameters(1) are provided by the central header file 'libTMCG.hh'.  You
have to include this file in all of your sources, either directly or
through some other included file.  Thus often you will simply write:

     #include <libTMCG.hh>

   There are no uniform C++ name spaces for the most parts of the
library.  Some classes and data types have the common prefix 'TMCG_*'
resp.  'VTMF_*' while others are composed of the author names and an
abbreviation of the title from the related research paper.  Further
there are internally used C functions which might produce conflicting
names.  These function names are prepended by 'mpz_*' because they are
extensions for the large integer support of the GNU Multiple Precision
Arithmetic Library.

   ---------- Footnotes ----------

   (1) The security parameters are fixed at compile time of LibTMCG.
Please don't change anything unless you know exactly what you are doing!
Beside the apparent security concerns you will probably break the
compatibility with other LibTMCG applications.


File: libTMCG.info,  Node: Building Sources,  Next: Initializing the Library,  Prev: Header Files and Name Spaces,  Up: Introduction

1.6 Building Sources
====================

If you want to compile a source file including the 'libTMCG.hh' header,
you must make sure that the compiler can find it in the directory
hierarchy.  This is achieved by adding the path of the corresponding
directory to the compilers include file search path.

   However, the path to the include file has been determined at the time
the source is configured.  To solve this problem, LibTMCG ships with a
small helper program 'libTMCG-config' that knows the path to the include
file and a few other configuration options.  The options that need to be
added to the compiler invocation are output by the '--cflags' option to
'libTMCG-config'.  The following example shows how it can be used at the
command line:

     g++ -c foo.cc `libTMCG-config --cflags`

   Adding the output of 'libTMCG-config --cflags' to the compilers
command line will ensure that the compiler can find the LibTMCG header
file.

   A similar problem occurs when linking your program with LibTMCG.
Again, the compiler has to find the library files.  Therefore the
correct installation path has to be added to the library search path.
To achieve this, the option '--libs' of 'libTMCG-config' can be used.
For convenience, this option also outputs all other stuff that is
required to link your program with LibTMCG (in particular, the '-lTMCG'
option).

   The example shows how to link 'foo.o' with LibTMCG to a program
called 'foo':

     g++ -o foo foo.o `libTMCG-config --libs`

   Of course, you can also combine both examples to a single command by
calling the shell script 'libTMCG-config' with both options:

     g++ -o foo foo.c `libTMCG-config --cflags --libs`

1.6.1 Building Sources Using GNU Automake
-----------------------------------------

You can use GNU Automake to obtain automatically generated Makefiles.
If you do so then you do not have to care about finding and invoking the
'libTMCG-config' script at all.  LibTMCG provides an Automake extension
that does all the stupid work for you.

 -- Macro: AM_PATH_LIBTMCG ([MINIMUM-VERSION], [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     Check whether LibTMCG (at least version MINIMUM-VERSION, if given)
     exists on the host system.  If it is found, execute
     ACTION-IF-FOUND, otherwise do ACTION-IF-NOT-FOUND.

     Additionally, the macro defines 'LIBTMCG_CFLAGS' to the flags
     needed for compilation in order to find the necessary header files,
     and 'LIBTMCG_LIBS' to the corresponding linker flags.

   You can use the defined variables in your 'Makefile.am' as follows:

     AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
     LDADD = $(LIBTMCG_LIBS)


File: libTMCG.info,  Node: Initializing the Library,  Prev: Building Sources,  Up: Introduction

1.7 Initializing the Library
============================

The first step is the initialization of LibTMCG. The following function
must be invoked early in your program, i.e., before you make use of any
other capability of LibTMCG.

 -- Function: bool init_libTMCG ()
     The function checks whether the installed third-party libraries
     match their required versions.  Further it initializes them and
     returns 'true', if everything was sound.  Otherwise 'false' is
     returned and an appropriate error message is sent to 'std::cerr'.

   Additionally, the function 'version_libTMCG' returns a string
containing the version number of the library in a common format.  It is
strongly recommended to check, whether the installed version matches
your requirements.

 -- Function: std::string version_libTMCG ()
     This function returns the version of the library in the format
     _major.minor.revision_.


File: libTMCG.info,  Node: Application Programming Interface,  Next: Examples,  Prev: Introduction,  Up: Top

2 Application Programming Interface
***********************************

* Menu:

* Preprocessor Defined Global Symbols::
* Data Types and Classes::


File: libTMCG.info,  Node: Preprocessor Defined Global Symbols,  Next: Data Types and Classes,  Up: Application Programming Interface

2.1 Preprocessor Defined Global Symbols
=======================================

Please note that the following macros are fixed at compile time of
LibTMCG and cannot be changed by your application.  They are only
provided here for informational purposes.

 -- Macro: TMCG_MR_ITERATIONS
     Defines the number of iterations for the Miller-Rabin primality
     test. 	The default value is '64' which implies a soundness error
     probability {} \le 4^{-64}.

 -- Macro: TMCG_GROTH_L_E
     Defines the security parameter \ell_e of Groth's interactive
     shuffle argument [Gr05].  The default value is '80' which	implies a
     soundness error probability {} \le 2^{-80}.  For the	intended
     purposes of LibTMCG this bound seems to be reasonable.

 -- Macro: TMCG_DDH_SIZE
     Defines the security parameter (field size in bit) of the group G
     which is used by the card encoding scheme of Barnett and
     Smart [BS03].  The underlying assumptions are DDH, CDH, and DLOG.
     The default value is '1024'.

 -- Macro: TMCG_DLSE_SIZE
     Defines the security parameter (subgroup size in bit) of the group
     G which is used by the card encoding scheme of Barnett and
     Smart [BS03].  The underlying assumptions are DLSE (related to DDH)
     and DLOG. The default value is '160'.

 -- Macro: TMCG_GCRY_MD_ALGO
     Defines the message digest algorithm for digital signatures and the
     Fiat-Shamir heuristic (see Fiat, Shamir: _How to prove yourself:
     Practical Solutions to Identification and Signature Problems_,
     1986).  The security of the most non-interactive zero-knowledge
     proofs (NIZK) is related to the so-called random oracle model,
     i.e., we suppose that the instantiated hash function behaves like
     an ideal random function (which cannot hold in a real world
     scenario).  However, this assumption seems to be reasonable, if the
     hash function is collision-resistant and carefully implemented.
     The default value 'GCRY_MD_RMD160' (1) chooses the hash algorithm
     RIPEMD-160 (see Dobbertin, Bosselaers, Preneel: _RIPEMD-160, a
     strengthened version of RIPEMD_, 1996) which has an output length
     of 160 bit.  Thus we gain a security level of approximately 2^{80},
     assuming that a birthday-attack is the best known attack against
     this hash function.

 -- Macro: TMCG_KEYID_SIZE
     Defines the length (in characters w.r.t.  'TMCG_MPZ_IO_BASE') for
     the distinctive suffix of the unique TMCG key identifier.  The
     default value is '8' which spans a reasonable name space for at
     least 2^{20} different TMCG keys (see 'TMCG_PublicKey').  However,
     sometimes it is required to use even smaller sizes.

     Each key identifier starts with the string '"ID"' followed by the
     decimal encoded value of 'TMCG_KEYID_SIZE' and the appended carret
     symbol '"^"'.  The final suffix contains 'TMCG_KEYID_SIZE'
     alphanumerical characters from the self signature of TMCG key.  The
     signature has enough entropy included to be used as unique key
     identifier.

 -- Macro: TMCG_KEY_NIZK_STAGE1
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 1) which convince all verifiers that the TMCG key was
     correctly generated.  The default value is '16' which implies a
     soundness error probability {} \le d^{-16}, where d = {\rm gcd}(m,
     \phi(m)).  This parameter is only relevant for the card encoding
     scheme of Schindelhauer.

 -- Macro: TMCG_KEY_NIZK_STAGE2
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 2) which convince all verifiers that the TMCG key was
     correctly generated.  The default value is '128' which implies a
     soundness error probability {} \le 2^{-128}.  This parameter is
     only relevant for the card encoding scheme of Schindelhauer.

 -- Macro: TMCG_KEY_NIZK_STAGE3
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 3) which convince all verifiers that the TMCG key was
     correctly generated.  The default value is '128' which implies a
     soundness error probability {} \le 2^{-128}.  This parameter is
     only relevant for the card encoding scheme of Schindelhauer.

 -- Macro: TMCG_LIBGCRYPT_VERSION
     Defines the required minimum version number of the GNU Crypto
     Library.  The default value is '"1.2.0"'.  During the
     initialization of LibTMCG (see 'init_libTMCG') it is checked,
     whether the version number of the linked shared object fulfills
     this condition.

 -- Macro: TMCG_LIBGMP_VERSION
     Defines the required minimum version number of the GNU Multiple
     Precision Arithmetic Library.  The default value is '"4.1.0"'.
     During the initialization of LibTMCG (see 'init_libTMCG') it is
     checked, whether the version number provided by the header file
     'gmp.h' and used at compile time of LibTMCG fulfills this
     condition.

 -- Macro: TMCG_MAX_CARDS
     Defines the maximum number of stackable cards.  The default value
     is '128'.

 -- Macro: TMCG_MAX_PLAYERS
     Defines the maximum number of players.  The default value is '32'.
     This parameter is only relevant for the card encoding scheme of
     Schindelhauer.

 -- Macro: TMCG_MAX_TYPEBITS
     Defines the maximum number of bits to represent the card type in
     the scheme of Schindelhauer.  On the other hand, this value
     determines the maximum size of the message space in the scheme of
     Barnett and Smart.  The default value is '8' which implies that 256
     different card types are possible.

 -- Macro: TMCG_MPZ_IO_BASE
     Defines the input and output base of the 'std::iostream' operators
     '<<' and '>>' which are used to encode large integers ('mpz_t').
     The default value is '36' which is currently the largest base
     supported by the GNU Multiple Precision Arithmetic Library.

 -- Macro: TMCG_PRAB_K0
     Defines the security parameter k_0 (in characters) of the PRab
     scheme (see Bellare, Rogaway: _The Exact Security of Digital
     Signatures - How to Sign with RSA and Rabin_, 1996).  The default
     value is '20' which implies a security level around 2^{80}.

 -- Macro: TMCG_QRA_SIZE
     Defines the security parameter (size of the modulus m = p \cdot q
     in bit) of the TMCG key.  The underlying assumptions are QRA and
     FACTOR. The default value is '1024'.  This parameter is only
     relevant for TMCG keys and Schindelhauer's encoding scheme.

 -- Macro: TMCG_SAEP_S0
     Defines the security parameter s_0 (in characters) of the
     Rabin-SAEP scheme (see Boneh: _Simplified OAEP for the RSA and
     Rabin Functions_, 2002).  The default value is '20' which implies a
     security around 2^{80} against CCA (Chosen Ciphertext Attacks).

 -- Macro: TMCG_HASH_COMMITMENT
     Defines whether shortened commitments are used in the shuffle
     verification procedure of Schindelhauer.  The default value is
     'true', because it will decrease the communication complexity
     significantly.  However, as an immediate consequence the soundness
     property is violated, if the used hash function 'TMCG_GCRY_MD_ALGO'
     is broken.

 -- Macro: TMCG_MAX_FPOWM_T
     Defines the maximum size of admissible exponents (in bit) used by
     fast exponentiation procedures.  The default value is '2048'.  Note
     that this parameter has a strong influence on the amount of memory
     allocated by LibTMCG since it determines the size of the
     precomputed tables.  However, it should be at least greater than
     'TMCG_DDH_SIZE' and 'TMCG_QRA_SIZE'.

   ---------- Footnotes ----------

   (1) This is a constant defined by the GNU Crypto Library.


File: libTMCG.info,  Node: Data Types and Classes,  Prev: Preprocessor Defined Global Symbols,  Up: Application Programming Interface

2.2 Data Types and Classes
==========================

This section describes all public data types and classes that are
necessary to create a secure card game.  Private methods and only
internally used members are not explained.

* Menu:

* Data Types::
* Classes::


File: libTMCG.info,  Node: Data Types,  Next: Classes,  Up: Data Types and Classes

2.2.1 Data Types
----------------

LibTMCG provides several data structures for cards, stacks, and
cryptographic keys.

2.2.1.1 Encoding Schemes for Cards
..................................

There exist two different encoding schemes that can be used for the
digital representation of playing cards.  In the scheme of
Schindelhauer [Sc98] the type of a card is shared among the players
through bit-wise representation by quadratic (non-)residues.  Thus the
security relies on the well-known QRA (Quadratic Residuosity
Assumption).  Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of card types.
Recently the much more efficient solution of Barnett and Smart [BS03]
has been implemented.  This encoding works on a cyclic group of prime
order and requires that the DDH (Decisional Diffie-Hellman Assumption)
holds there.

   For both schemes LibTMCG provides a structure whose name contains the
suffix 'Card'.  This data type is used to represent an open or even a
masked card.  Further, there is a corresponding structure whose name
contains the suffix 'CardSecret'.  This data type is used to represent
the secret values involved in a card masking operation.

   Because of the reduced computational and communication complexity
(see [St05] for details) the usage of the second card encoding scheme,
i.e.  'VTMF_Card' and 'VTMF_CardSecret', is highly recommended.

 -- Data type: TMCG_Card
     This 'struct' represents a card in the encoding scheme	of
     Schindelhauer [Sc98].  The type of the card is shared	among the
     players by quadratic residues and non-residues,	respectively.  Thus
     the security relies on the Quadratic	Residuosity Assumption.

      -- Member of TMCG_Card: std::vector< std::vector<MP_INT> > z
          This k\times w-matrix encodes the type of the	corresponding
          card in a shared way.  For each of the	k players there is a
          separate row and for each of	the w bits in the binary
          representation of the	type there is a column.  The elements
          are numbers from	the group {\bf Z}^{\circ}_{m_i} where m_i	is
          the public modulus of the ith player.

      -- Constructor on TMCG_Card: TMCG_Card ()
          This default constructor initializes the card with an empty
          1\times 1-matrix.  Later the method	'TMCG_Card::resize' can be
          used to enlarge the	card representation.

      -- Constructor on TMCG_Card: TMCG_Card ('size_t' k, 'size_t' w)
          This constructor initializes the card with an empty	k\times
          w-matrix.  The parameter K is the	number of players and W is
          the maximum number	of bits used by the binary representation
          of the card	type.

      -- Constructor on TMCG_Card: TMCG_Card ('const TMCG_Card&' that)
          This is a simple copy-constructor and THAT is the card to be
          copied.

      -- Operator on TMCG_Card: TMCG_Card& = ('const TMCG_Card&' that)
          This is a simple assignment-operator and THAT is the card to
          be assigned.

      -- Operator on TMCG_Card: bool == ('const TMCG_Card&' that)
          This operator tests two card representations for equality.

      -- Operator on TMCG_Card: bool != ('const TMCG_Card&' that)
          This operator tests two card representations for inequality.

      -- Method on TMCG_Card: void resize ('size_t' k, 'size_t' w)
          This method resizes the representation of the card. 	The
          current content of the member 'z' will be	released and a new
          k\times w-matrix is created. 	The parameter K is the number of
          players and	W is the maximum number of bits used by the binary
          representation of the card type.

      -- Method on TMCG_Card: bool import ('std::string' s)
          This method imports the content of the member 'z' from	the
          correctly formatted input string S.  It returns	'true', if the
          import was successful.

      -- Destructor on TMCG_Card: ~TMCG_Card ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_Card: std::ostream& << ('std::ostream&' out, 'const
          TMCG_Card&' card)
     This operator exports the content of the member 'z'	(of the given
     'TMCG_Card' CARD) to the output	stream OUT.

 -- Operator on TMCG_Card: std::istream& >> ('std::istream&' in,
          'TMCG_Card&' card)
     This operator imports the content of the member 'z'	(of the given
     'TMCG_Card' CARD) from the input	stream IN.  The data has to be
     delimited by a newline	character.  The 'failbit' of the stream is
     set, if any	parse error occurred.

 -- Data type: TMCG_CardSecret
     This 'struct' represents the secret used for a card masking
     operation in the original encoding scheme of Schindelhauer [Sc98].

      -- Member of TMCG_CardSecret: std::vector< std::vector<MP_INT> > r
          This k\times w-matrix encodes the first part of the	secret.
          For each of the k players there is a separate	row and for each
          of the w bits in the binary representation	of the
          corresponding card type there is a column.  The elements are
          numbers from the group {\bf Z}^{\circ}_{m_i} where m_i	is the
          public modulus of the ith player.

      -- Member of TMCG_CardSecret: std::vector< std::vector<MP_INT> > b
          This k\times w-matrix encodes the second part of the	secret.
          For each of the k players there is a separate	row and for each
          of the w bits in the binary representation	of the
          corresponding card type there is a column.  The elements are
          simply numbers from \{0, 1\}.

      -- Constructor on TMCG_CardSecret: TMCG_CardSecret ()
          This default constructor initializes both members with an
          empty	1\times 1-matrix.  Later the method
          'TMCG_CardSecret::resize' can be used to enlarge the	card
          representation.

      -- Constructor on TMCG_CardSecret: TMCG_CardSecret ('size_t' k,
               'size_t' w)
          This constructor initializes both members with an empty
          k\times w-matrix.  The parameter K is the	number of players
          and W is the maximum number	of bits used by the binary
          representation of the	corresponding card type.

      -- Constructor on TMCG_CardSecret: TMCG_CardSecret ('const
               TMCG_CardSecret&' that)
          This is a simple copy-constructor and THAT is the secret to be
          copied.

      -- Operator on TMCG_CardSecret: TMCG_CardSecret& = ('const
               TMCG_CardSecret&' that)
          This is a simple assignment-operator and THAT is the secret to
          be assigned.

      -- Method on TMCG_CardSecret: void resize ('size_t' k, 'size_t' w)
          This method resizes the representation of the secret. 	The
          current content of the members 'r' and 'b'	will be released
          and new k\times w-matrices are	created.  The parameter K is
          the number of players and	W is the maximum number of bits used
          by the binary	representation of the corresponding card type.

      -- Method on TMCG_CardSecret: bool import ('std::string' s)
          This method imports the content of the members 'r' and	'b'
          from the correctly formatted input string S. 	It returns
          'true', if the import was successful.

      -- Destructor on TMCG_CardSecret: ~TMCG_CardSecret ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_CardSecret: std::ostream& << ('std::ostream&' out,
          'const TMCG_CardSecret&' cardsecret)
     This operator exports the content of the members 'r'	and 'b' (of
     the given 'TMCG_CardSecret'	CARDSECRET) to the output stream OUT.

 -- Operator on TMCG_CardSecret: std::istream& >> ('std::istream&' in,
          'TMCG_CardSecret&' cardsecret)
     This operator imports the content of the members 'r'	and 'b' (of
     the given 'TMCG_CardSecret'	CARDSECRET) from the input stream IN.
     The data has to be delimited by a newline character. 	The 'failbit'
     of the stream is set, if any parse error	occurred.

 -- Data type: VTMF_Card
     This 'struct' represents a card in the encoding scheme	of Barnett
     and Smart [BS03].  Here we use the discrete logarithm	based
     instantiation of their general cryptographic primitive	VTMF
     (Verifiable K-out-of-K Threshold Masking	Function).  The security
     relies on the DDH assumption in the	underlying abelian group G.

      -- Member of VTMF_Card: mpz_t c_1
          This is the first part of the encrypted card type. 	It is an
          element from the underlying group G.

      -- Member of VTMF_Card: mpz_t c_2
          This is the second part of the encrypted card type. 	It is
          also an element from the underlying group G.

      -- Constructor on VTMF_Card: VTMF_Card ()
          This default constructor initializes an empty card where	the
          members 'c_1' and 'c_2' are set to zero.

      -- Constructor on VTMF_Card: VTMF_Card ('const VTMF_Card&' that)
          This is a simple copy-constructor and THAT is the	card to be
          copied.

      -- Operator on VTMF_Card: VTMF_Card& = ('const VTMF_Card&' that)
          This is a simple assignment-operator and THAT is	the card to
          be assigned.

      -- Operator on VTMF_Card: bool == ('const VTMF_Card&' that)
          This operator tests two card representations for equality.

      -- Operator on VTMF_Card: bool != ('const VTMF_Card&' that)
          This operator tests two card representations for inequality.

      -- Method on VTMF_Card: bool import ('std::string' s)
          This method imports the content of the members 'c_1'	and 'c_2'
          from a correctly formatted input string	S.  It returns 'true',
          if the import was successful.

      -- Destructor on VTMF_Card: ~VTMF_Card ()
          This destructor releases all occupied resources.

 -- Operator on VTMF_Card: std::ostream& << ('std::ostream&' out, 'const
          VTMF_Card&' card)
     This operator exports the content of the members 'c_1'	and 'c_2'
     (of the given 'VTMF_Card' CARD)	to the output stream OUT.

 -- Operator on VTMF_Card: std::istream& >> ('std::istream&' in,
          'VTMF_Card&' card)
     This operator imports the content of the members 'c_1'	and 'c_2'
     (of the given 'VTMF_Card' CARD)	from the input stream IN.  The data
     has to be delimited	by a newline character.  The 'failbit' of the
     stream is	set, if any parse error occurred.

 -- Data type: VTMF_CardSecret
     This 'struct' represents the secrets used in the card masking
     operation by the encoding scheme of Barnett and Smart [BS03].

      -- Member of VTMF_CardSecret: mpz_t r
          This member is the exponent (randomizer) used in the masking
          operation. 	It should be chosen uniformly and randomly from
          {\bf Z}_q	where q is the order of the finite abelian group G
          for which the DDH assumption holds.

          According to the results of Koshiba and Kurosawa (see _Short
          Exponent	Diffie-Hellman Problems_, PKC 2004, LNCS 2947) the
          length of	this exponent can be shorten to a more efficient
          size (e.g.  160 bit),	if the corresponding generator of G is
          adjusted as well.  Under the	additional DLSE (Discrete
          Logarithm with Short Exponents)	assumption the DDH problem in
          G seems to be still hard. 	By such an optimization trick we
          gain a great performance advantage for	almost all modular
          exponentiations that are computed during the masking
          operation, if the VTMF primitive was instantiated by the later
          explained	class 'BarnettSmartVTMF_dlog_GroupQR'.  Furthermore,
          the size of the	card secret is substantially reduced which
          results in an improved	communication complexity.

      -- Constructor on VTMF_CardSecret: VTMF_CardSecret ()
          This default constructor initializes the secret with an	empty
          member 'r'.

      -- Constructor on VTMF_CardSecret: VTMF_CardSecret ('const
               VTMF_CardSecret&' that)
          This is a simple copy-constructor and THAT is the secret to be
          copied.

      -- Operator on VTMF_CardSecret: VTMF_CardSecret& = ('const
               VTMF_CardSecret&' that)
          This is a simple assignment-operator and THAT is the secret to
          be assigned.

      -- Method on VTMF_CardSecret: bool import ('std::string' s)
          This method imports the content of the member 'r'	from the
          correctly formatted input string S. 	It returns 'true', if the
          import was successful.

      -- Destructor on VTMF_CardSecret: ~VTMF_CardSecret ()
          This destructor releases all occupied resources.

 -- Operator on VTMF_CardSecret: std::ostream& << ('std::ostream&' out,
          'const VTMF_CardSecret&' cardsecret)
     This operator exports the content of the member 'r'	(of the given
     'VTMF_CardSecret' CARDSECRET)	to the output stream OUT.

 -- Operator on VTMF_CardSecret: std::istream& >> ('std::istream&' in,
          'VTMF_CardSecret&' cardsecret)
     This operator imports the content of the member 'r'	(of the given
     'VTMF_CardSecret' CARDSECRET)	from the input stream IN.  The data
     has to be	delimited by a newline character.  The 'failbit' of	the
     stream is set, if any parse error occurred.

2.2.1.2 Stacks
..............

All of the following data types are generic containers that can be
instantiated as C++ templates with the former explained 'Card' and
'CardSecret' data types, respectively.  Note the maximum number of
stackable data is upper-bounded by 'TMCG_MAX_CARDS'.  There is no error
reported, if this limit is exceeded.

 -- Data type: TMCG_Stack< CARDTYPE>
     This 'struct' is a simple container for cards of the specified
     'CARDTYPE'.  Currently, the elements can be either of type
     'TMCG_Card' or 'VTMF_Card' depending on which kind of encoding
     scheme is used.  The 'TMCG_Stack' structure is mainly used to
     represent	a stack of masked cards, i.e., playing cards that are
     stacked in a face-down	manner.  It can be either a public stack
     where all participants have access to	or even a private stack, e.g.
     the players' hand.  If the corresponding	card types are known it
     can also serve as an "open stack", although	'TMCG_OpenStack' is
     more suitable in that case.

      -- Member of TMCG_Stack: std::vector<CARDTYPE> stack
          This is the container that is used internally for storing the
          cards.

      -- Constructor on TMCG_Stack: TMCG_Stack ()
          This default constructor initializes an empty stack.

      -- Operator on TMCG_Stack: TMCG_Stack& = ('const
               TMCG_Stack<CARDTYPE>&' that)
          This is a simple assignment-operator and THAT is the stack to
          be assigned.

      -- Operator on TMCG_Stack: bool == ('const TMCG_Stack<CARDTYPE>&'
               that)
          This operator tests two stacks for equality.  It checks
          whether the	sizes of the stacks and the contained cards are
          equal with respect to	the implied order.

      -- Operator on TMCG_Stack: bool != ('const TMCG_Stack<CARDTYPE>&'
               that)
          This operator tests two stacks for inequality.  It returns
          'true', if	either the sizes does not match or at least two
          corresponding cards are	not equal.

      -- Operator on TMCG_Stack: const CARDTYPE& [] ('size_t' n)
          This operator provides read-only random access to the
          contained cards. 	It returns a const-reference to the Nth card
          from the top of the stack.

      -- Operator on TMCG_Stack: CARDTYPE& [] ('size_t' n)
          This operator provides random access to the contained cards.
          It returns a reference to the Nth card from the top of the
          stack.

      -- Method on TMCG_Stack: size_t size ()
          This method returns the size of the stack.

      -- Method on TMCG_Stack: void push ('const CARDTYPE&' c)
          This method pushes the card C to the back of the stack.

      -- Method on TMCG_Stack: void push ('const TMCG_Stack<CARDTYPE>&'
               s)
          This method pushes the stack S to the back of the stack.

      -- Method on TMCG_Stack: void push ('const
               TMCG_OpenStack<CARDTYPE>&' s)
          This method pushes the cards of the open stack S to the back
          of the stack.

      -- Method on TMCG_Stack: bool empty ()
          This method returns 'true', if the stack is empty.

      -- Method on TMCG_Stack: bool pop ('CARDTYPE&' c)
          This method removes a card from the back and stores the data
          in C. 	It returns 'true', if the stack was not empty and thus
          C	contains useful data.

      -- Method on TMCG_Stack: void clear ()
          This method clears the stack, i.e., it removes all cards.

      -- Method on TMCG_Stack: bool find ('const CARDTYPE&' c)
          This method returns 'true', if the card C was found in the
          stack.

      -- Method on TMCG_Stack: bool remove ('const CARDTYPE&' c)
          This method removes the top-most card from the stack which is
          equal to	C.  It returns 'true', if the card was found and
          successfully	removed.

      -- Method on TMCG_Stack: size_t removeAll ('const CARDTYPE&' c)
          This method removes every card from the stack which is equal
          to C. 	It returns the number of removed cards.

      -- Method on TMCG_Stack: bool import ('std::string' s)
          This method imports the stack from the correctly formatted
          input string	S.  It returns 'true', if the import was
          successful.

      -- Destructor on TMCG_Stack: ~TMCG_Stack ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_Stack: std::ostream& << ('std::ostream&' out,
          'const TMCG_Stack<CARDTYPE>&' stack)
     This operator exports the given STACK to the output stream OUT.

 -- Operator on TMCG_Stack: std::istream& >> ('std::istream&' in,
          'TMCG_Stack<CARDTYPE>&' stack)
     This operator imports the given STACK from the input stream IN.
     The data has to be delimited by a newline character.  The 'failbit'
     of	the stream is set, if any parse error occurred.

 -- Data type: TMCG_OpenStack< CARDTYPE>
     This 'struct' is a simple container for cards of the specified
     'CARDTYPE' whose types are known.  The elements are pairs where	the
     first component is the type and the second component is the
     corresponding	card.  The card type is represented by a 'size_t'
     integer.  Currently, the	cards can be either of type 'TMCG_Card' or
     'VTMF_Card' depending on	which kind of encoding scheme is used.

      -- Member of TMCG_OpenStack: std::vector<std::pair<size_t,
               CARDTYPE> > stack
          This is the container that is used internally for storing the
          pairs.

      -- Constructor on TMCG_OpenStack: TMCG_OpenStack ()
          This default constructor initializes an empty stack.

      -- Operator on TMCG_OpenStack: TMCG_OpenStack& = ('const
               TMCG_OpenStack<CARDTYPE>&' that)
          This is a simple assignment-operator and THAT is the stack to
          be assigned.

      -- Operator on TMCG_OpenStack: bool == ('const
               TMCG_OpenStack<CARDTYPE>&' that)
          This operator tests two stacks for equality.  It checks
          whether the types,	the sizes, and the contained cards are
          equal with respect to the stack order.

      -- Operator on TMCG_OpenStack: bool != ('const
               TMCG_OpenStack<CARDTYPE>&' that)
          This operator tests two stacks for inequality.  It returns
          'true', if	either the sizes resp.  types does not match or at
          least two corresponding cards	are not equal.

      -- Operator on TMCG_OpenStack: const std::pair<size_t, CARDTYPE>&
               [] ('size_t' n)
          This operator provides read-only random access to the
          contained pairs. 	It returns a const-reference to the Nth pair
          from the top of the stack.

      -- Operator on TMCG_OpenStack: std::pair<size_t, CARDTYPE>& []
               ('size_t' n)
          This operator provides random access to the contained pairs.
          It returns a reference to the Nth pair from the top of the
          stack.

      -- Method on TMCG_OpenStack: size_t size ()
          This method returns the size of the stack.

      -- Method on TMCG_OpenStack: void push ('const std::pair<size_t,
               CARDTYPE>&' p)
          This method pushes the pair P to the back of the stack.  The
          first	component is the type and the second component is the
          corresponding card	representation.

      -- Method on TMCG_OpenStack: void push ('size_t' type, 'const
               CARDTYPE&' c)
          This method pushes a pair to the back of the stack.  The
          parameter TYPE	is the card type and C is the corresponding
          card representation.

      -- Method on TMCG_OpenStack: void push ('const
               TMCG_OpenStack<CARDTYPE>&' s)
          This method pushes the pairs of the stack S to the back	of
          this stack.

      -- Method on TMCG_OpenStack: bool empty ()
          This method returns 'true', if the stack is empty.

      -- Method on TMCG_OpenStack: bool pop ('size_t&' type, 'CARDTYPE&'
               c)
          This method removes a pair from the back of the stack.  It
          stores the card type	in TYPE and the	representation in C.  It
          returns 'true', if the stack	was not empty and thus TYPE and C
          contain useful data.

      -- Method on TMCG_OpenStack: void clear ()
          This method clears the stack, i.e., it removes all pairs.

      -- Method on TMCG_OpenStack: bool find ('size_t' type)
          This method returns 'true', if a pair with the first component
          TYPE was	found in the stack.

      -- Method on TMCG_OpenStack: bool remove ('size_t' type)
          This method removes the top-most pair with the first component
          TYPE from the	stack.  It returns 'true', if such a pair was
          found and successfully removed.

      -- Method on TMCG_OpenStack: size_t removeAll ('size_t' type)
          This method removes every pair from the stack whose first
          component is equal to	TYPE.  Further it returns the number of
          removed pairs.

      -- Method on TMCG_OpenStack: bool move ('size_t' type,
               'TMCG_Stack<CARDTYPE>&' s)
          This method moves the top-most card representation of the
          given TYPE to another	stack S.  It returns 'true', if such a
          pair was found and successfully moved.

      -- Destructor on TMCG_OpenStack: ~TMCG_OpenStack ()
          This destructor releases all occupied resources.

 -- Data type: TMCG_StackSecret< CARDSECRETTYPE>
     This 'struct' is a simple container for the secrets involved	in the
     masking operation of cards.  Additionally, the permutation	of a
     corresponding shuffle of the stack is stored. 	The elements are
     pairs where the first component is a permutation	index of type
     'size_t' and the second component is a card	secret of the specified
     'CARDSECRETTYPE'.  Currently,	such secrets can be either of type
     'TMCG_CardSecret' or	'VTMF_CardSecret' depending on which kind of
     encoding scheme	is used.

      -- Member of TMCG_StackSecret: std::vector<std::pair<size_t,
               CARDSECRETTYPE> > stack
          This is the container that is used internally for storing the
          pairs.

      -- Constructor on TMCG_StackSecret: TMCG_StackSecret ()
          This default constructor initializes an empty stack secret.

      -- Operator on TMCG_StackSecret: TMCG_StackSecret& = ('const
               TMCG_StackSecret<CARDSECRETTYPE>&' that)
          This is a simple assignment-operator and THAT is the	stack
          secret to be assigned.

      -- Operator on TMCG_StackSecret: const std::pair<size_t,
               CARDSECRETTYPE>& [] ('size_t' n)
          This operator provides read-only random access to the
          contained pairs. 	It returns a const-reference to the Nth pair
          from the top of the stack secret.

      -- Operator on TMCG_StackSecret: std::pair<size_t,
               CARDSECRETTYPE>& [] ('size_t' n)
          This operator provides random access to the contained pairs.
          It returns a reference to the Nth pair from the top of the
          stack secret.

      -- Method on TMCG_StackSecret: size_t size ()
          This method returns the size of the stack secret.

      -- Method on TMCG_StackSecret: void push ('size_t' index, 'const
               CARDSECRETTYPE&' cs)
          This method pushes a pair to the back of the stack secret.
          The parameter INDEX	is the permutation index and CS is the
          corresponding card secret.

      -- Method on TMCG_StackSecret: void clear ()
          This method clears the stack secret, i.e., it removes all
          pairs.

      -- Method on TMCG_StackSecret: size_t find_position ('size_t'
               index)
          This method searches for a given permutation index in the
          stack secret. 	It returns the corresponding position(1) in	the
          stack secret, if the INDEX was found.  Otherwise, the size of
          the stack secret is returned.  Please note that in this case
          the returned	value is not a valid position for an access to
          the stack secret.

      -- Method on TMCG_StackSecret: bool find ('size_t' index)
          This method searches for a given permutation index in the
          stack secret. 	It returns 'true', if such an INDEX was found.

      -- Method on TMCG_StackSecret: bool import ('std::string' s)
          This method imports the stack secret from a correctly
          formatted input string	S.  It returns 'true', if the import
          was successful.

      -- Destructor on TMCG_StackSecret: ~TMCG_StackSecret ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_StackSecret: std::ostream& << ('std::ostream&' out,
          'const TMCG_StackSecret<CARDSECRETTYPE>&' stacksecret)
     This operator exports the given STACKSECRET to the output stream
     OUT.

 -- Operator on TMCG_StackSecret: std::istream& >> ('std::istream&' in,
          'TMCG_StackSecret<CARDSECRETTYPE>&' stacksecret)
     This operator imports the given STACKSECRET from the input stream
     IN. 	The data has to be delimited by a newline character.  The
     'failbit' of	the stream is set, if any parse error occurred.

2.2.1.3 Cryptographic Keys
..........................

LibTMCG only provides corresponding data types for keys used by the
encoding scheme of Schindelhauer [Sc98], because it is not efficient to
perform the key generation in every new game session.  Furthermore, in
general you can encrypt and sign messages to ensure confidentiality and
integrity, even if the scheme of Barnett and Smart [BS03] has been
applied for the card encoding.  Therefore these structures may be of
independent interest, for example to establish authenticated
communication channels between players.  However, like for all public
key cryptosystems a trusted PKI (Public Key Infrastructure) is needed.
This might not be a serious requirement in distributed game
environments, because the players can compare their key fingerprints by
telephone or a service provider can issue public key certificates.

 -- Data type: TMCG_SecretKey
     This 'struct' represents the secret part of the TMCG key.  The
     underlying public key cryptosystem is due to Rabin with minor
     modifications for encryption padding (SAEP scheme	of Boneh) and
     digital signatures (PRab scheme of Bellare and Rogaway).

      -- Member of TMCG_SecretKey: std::string name
          This string contains the name or a pseudonym of the key owner.

      -- Member of TMCG_SecretKey: std::string email
          This string contains the email address of the key owner.

      -- Member of TMCG_SecretKey: std::string type
          This string contains information about the key type.  The
          common	prefix is 'TMCG/RABIN'.  It is followed by the decimal
          encoded	bit size of the modulus m.  The suffix 'NIZK' signals
          that the correctness of the key is shown by an appended
          non-interactive	zero-knowledge proof.  The single parts are
          separated by underscore	characters '_', e.g.,
          'TMCG/RABIN_1024_NIZK' has the correct	form.  However, the
          suffix can be left empty, if the key is	only used for
          encryption and signing (non-NIZK key).

      -- Member of TMCG_SecretKey: std::string nizk
          This string contains two stages of the non-interactive
          zero-knowledge	proof of Gennaro, Micciancio, and Rabin (_An
          Efficient Non-Interactive	Statistical Zero-Knowledge Proof
          System for Quasi-Safe Prime Products_,	ACM CCS 1998).  The
          proof shows that m was correctly	generated as product of two
          primes both congruent to 3 (modulo 4). 	Further there is
          another non-interactive zero-knowledge proof appended	which
          shows that the condition y\in{\bf NQR}^\circ_m holds.

      -- Member of TMCG_SecretKey: std::string sig
          This string contains the self signature of the public key.

      -- Member of TMCG_SecretKey: mpz_t m
          This is the public modulus m = p \cdot q which is the product
          of two secret primes p and q.  The size of m	is determined by
          the security parameter 'TMCG_QRA_SIZE'.

      -- Member of TMCG_SecretKey: mpz_t y
          This is the public quadratic non-residue y\in {\bf
          NQR}^\circ_m	which is used in several zero-knowledge proofs of
          Schindelhauer's	encoding scheme [Sc98].

      -- Member of TMCG_SecretKey: mpz_t p
          This is the secret prime number p which is a factor of the
          modulus m.

      -- Member of TMCG_SecretKey: mpz_t q
          This is the secret prime number q which is a factor of the
          modulus m.

      -- Constructor on TMCG_SecretKey: TMCG_SecretKey ()
          This default constructor initializes an empty secret key.

      -- Constructor on TMCG_SecretKey: TMCG_SecretKey ('const
               std::string&' n, 'const std::string&' e, 'unsigned long
               int' keysize '=TMCG_QRA_SIZE', 'bool' nizk_key '=true')
          This constructor generates a new secret key where N is the
          name or a	pseudonym of the owner, E is a corresponding email
          address,	KEYSIZE is the desired bit length of the modulus m,
          and NIZK_KEY indicates whether or not a NIZK proof will be
          appended.  The	default value of the third argument is set to
          'TMCG_QRA_SIZE',	if KEYSIZE is omitted in the call.  The
          default value of the fourth argument is set to 'true',
          whenever it is omitted in the call.  Depending on KEYSIZE and
          NIZK_KEY	the generation is a very time-consuming task and dots
          are sent to	'std::cerr' as a progress indicator.

      -- Constructor on TMCG_SecretKey: TMCG_SecretKey ('const
               std::string&' s)
          This constructor initializes the key from a correctly
          formatted	input string S.

      -- Constructor on TMCG_SecretKey: TMCG_SecretKey ('const
               TMCG_SecretKey&' that)
          This is a simple copy-constructor and THAT is the key to be
          copied.

      -- Operator on TMCG_SecretKey: TMCG_SecretKey& = ('const
               TMCG_SecretKey&' that)
          This is a simple assignment-operator and THAT is the key to be
          assigned.

      -- Method on TMCG_SecretKey: bool check ()
          This method tests whether the self signature is valid and
          whether the	non-interactive zero-knowledge proofs are sound.
          It returns 'true',	if all checks have been successfully
          passed.  Due to the computational	complexity of the
          verification procedure these checks are extremely
          time-consuming.

      -- Method on TMCG_SecretKey: std::string fingerprint ()
          This method returns the fingerprint of the key.  The
          fingerprint is the	hexadecimal notation of the hash value
          (algorithm 'TMCG_GCRY_MD_ALGO')	on the members 'name',
          'email', 'type', 'm', 'y',	'nizk', and 'sig'.

      -- Method on TMCG_SecretKey: std::string selfid ()
          This method returns the real value of the self signature.  The
          string	'ERROR' is returned, if any parse error occurred.  The
          string	'SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG' is
          returned,	if the self signature 'sig' was empty.

      -- Method on TMCG_SecretKey: std::string keyid ('size_t' size
               '=TMCG_KEYID_SIZE')
          This method returns the unique key identifier of length SIZE.
          The default value of the first argument is set to
          'TMCG_KEYID_SIZE',	if SIZE is omitted in the call.

      -- Method on TMCG_SecretKey: size_t keyid_size ('const
               std::string&' s)
          This method returns the length of the unique key identifier S.
          Zero is returned, if any parse error occurred.

      -- Method on TMCG_SecretKey: std::string sigid ('std::string' s)
          This method returns the unique key identifier which is
          included in the	signature S.  The string 'ERROR' is returned,
          if any parse	error occurred.

      -- Method on TMCG_SecretKey: bool import ('std::string' s)
          This method imports the key from a correctly formatted input
          string	S.  It returns 'true', if the import was successful.

      -- Method on TMCG_SecretKey: bool decrypt ('char*' value,
               'std::string' s)
          This method decrypts the given encryption packet S and stores
          the content in VALUE which is a pointer to a character array
          of size 'TMCG_SAEP_S0'.  The method returns 'true', if the
          decryption was successful.

      -- Method on TMCG_SecretKey: std::string sign ('const
               std::string&' data)
          This method returns a digital signature on DATA.

      -- Method on TMCG_SecretKey: std::string encrypt ('const char*'
               value)
          This method encrypts the content of VALUE which is a pointer
          to a	character array of size 'TMCG_SAEP_S0'.  The method
          returns a	corresponding encryption packet that can be
          decrypted by the owner of the	secret key.

      -- Method on TMCG_SecretKey: bool verify ('const std::string&'
               data, 'std::string' s)
          This method verifies whether the signature S on DATA is valid
          or not.  It returns 'true', if everything was sound.

      -- Destructor on TMCG_SecretKey: ~TMCG_SecretKey ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_SecretKey: std::ostream& << ('std::ostream&' out,
          'const TMCG_SecretKey&' key)
     This operator exports the given KEY to the output stream OUT.

 -- Operator on TMCG_SecretKey: std::istream& >> ('std::istream&' in,
          'TMCG_SecretKey&' key)
     This operator imports the given KEY from the input stream IN. 	The
     data has to be delimited by a newline character.  The 'failbit'	is
     set, if any parse error occurred.

 -- Data type: TMCG_PublicKey
     This 'struct' represents the public part of the TMCG key.

      -- Member of TMCG_PublicKey: std::string name
          This string contains the name or a pseudonym of the key owner.

      -- Member of TMCG_PublicKey: std::string email
          This string contains the email address of the key owner.

      -- Member of TMCG_PublicKey: std::string type
          This string contains information about the key type.  The
          common	prefix is 'TMCG/RABIN'.  It is followed by the decimal
          encoded	bit size of the modulus m.  The suffix 'NIZK' signals
          that the correctness of the key is shown by an appended
          non-interactive	zero-knowledge proof.  The single parts are
          separated by underscore	characters '_', e.g.,
          'TMCG/RABIN_1024_NIZK' has the correct	form.  However, the
          suffix can be left empty, if the key is	only used for
          encryption and signing.

      -- Member of TMCG_PublicKey: std::string nizk
          This string contains two stages of non-interactive
          zero-knowledge	proof of Gennaro, Micciancio and Rabin (ACM
          CCS, 1998).  They show	that the modulus m was correctly
          generated.  Further there is another	non-interactive
          zero-knowledge proof appended which shows that the condition
          y\in{\bf NQR}^\circ_m holds.

      -- Member of TMCG_PublicKey: std::string sig
          This string contains the self signature of the public key.

      -- Member of TMCG_PublicKey: mpz_t m
          This is the public modulus m = p \cdot q which is the product
          of two secret primes p and q.  The size of m	is determined by
          the security parameter 'TMCG_QRA_SIZE'.

      -- Member of TMCG_PublicKey: mpz_t y
          This is the public quadratic non-residue y\in {\bf
          NQR}^\circ_m	which is used by several zero-knowledge proofs of
          the toolbox.

      -- Constructor on TMCG_PublicKey: TMCG_PublicKey ()
          This default constructor initializes an empty public key.

      -- Constructor on TMCG_PublicKey: TMCG_PublicKey ('const
               TMCG_SecretKey&' skey)
          This constructor initializes the key using public values	of
          the secret key SKEY.

      -- Constructor on TMCG_PublicKey: TMCG_PublicKey ('const
               TMCG_PublicKey&' pkey)
          This is a simple copy-constructor and PKEY is the key to be
          copied.

      -- Operator on TMCG_PublicKey: TMCG_PublicKey& = ('const
               TMCG_PublicKey&' that)
          This is a simple assignment-operator and THAT is the key to be
          assigned.

      -- Method on TMCG_PublicKey: bool check ()
          This method tests whether the self signature is valid and
          whether the	non-interactive zero-knowledge proofs are sound.
          It returns 'true',	if all checks have been successfully
          passed.  Due to the computational	complexity of the
          verification procedure these checks are extremely
          time-consuming.

      -- Method on TMCG_PublicKey: std::string fingerprint ()
          This method returns the fingerprint of the key.  The
          fingerprint is the	hexadecimal notation of the hash value
          (algorithm 'TMCG_GCRY_MD_ALGO')	on the members 'name',
          'email', 'type', 'm', 'y',	'nizk', and 'sig'.

      -- Method on TMCG_PublicKey: std::string selfid ()
          This method returns the real value of the self signature.  The
          string	'ERROR' is returned, if any parse error occurred.  The
          string	'SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG' is
          returned,	if the self signature 'sig' was empty.

      -- Method on TMCG_PublicKey: std::string keyid ('size_t' size
               '=TMCG_KEYID_SIZE')
          This method returns the unique key identifier of length SIZE.
          The default value of the first argument is set to
          'TMCG_KEYID_SIZE',	if SIZE is omitted in the call.

      -- Method on TMCG_PublicKey: size_t keyid_size ('const
               std::string&' s)
          This method returns the length of the unique key identifier S.
          Zero is returned, if any parse error occurred.

      -- Method on TMCG_PublicKey: std::string sigid ('std::string' s)
          This method returns the unique key identifier which is
          included in the	signature S.  The string 'ERROR' is returned,
          if any parse	error occurred.

      -- Method on TMCG_PublicKey: bool import ('std::string' s)
          This method imports the key from a correctly formatted input
          string	S.  It returns 'true', if the import was successful.

      -- Method on TMCG_PublicKey: std::string encrypt ('const char*'
               value)
          This method encrypts the content of VALUE which is a pointer
          to a	character array of size 'TMCG_SAEP_S0'.  The method
          returns a	corresponding encryption packet that can be
          decrypted by the owner of the	secret key.

      -- Method on TMCG_PublicKey: bool verify ('const std::string&'
               data, 'std::string' s)
          This method verifies whether the signature S on DATA is valid
          or not.  It returns 'true', if everything was sound.

      -- Destructor on TMCG_PublicKey: ~TMCG_PublicKey ()
          This destructor releases all occupied resources.

 -- Operator on TMCG_PublicKey: std::ostream& << ('std::ostream&' out,
          'const TMCG_PublicKey&' key)
     This operator exports the given KEY to the output stream OUT.

 -- Operator on TMCG_PublicKey: std::istream& >> ('std::istream&' in,
          'TMCG_PublicKey&' key)
     This operator imports the given KEY from the input stream IN. 	The
     data has to be delimited by a newline character.  The 'failbit'	is
     set, if any parse error occurred.

 -- Data type: TMCG_PublicKeyRing
     This 'struct' is just a simple container for TMCG public keys.
     There are	no particular methods provided by 'TMCG_PublicKeyRing'.
     You have to use	the regular interface of the STL container
     'std::vector' to access the	single keys of the ring.

      -- Member of TMCG_PublicKeyRing: std::vector<TMCG_PublicKey> keys
          This is the real container that is used to store the keys.

      -- Constructor on TMCG_PublicKeyRing: TMCG_PublicKeyRing ()
          This default constructor initializes an empty public key ring.

      -- Constructor on TMCG_PublicKeyRing: TMCG_PublicKeyRing ('size_t'
               n)
          This constructor initializes the container for storing exactly
          N keys.

      -- Destructor on TMCG_PublicKeyRing: ~TMCG_PublicKeyRing ()
          This destructor releases all occupied resources.

   ---------- Footnotes ----------

   (1) According to the behavior	of the '[]'-operator, the zero denotes
always the top-most position.


File: libTMCG.info,  Node: Classes,  Prev: Data Types,  Up: Data Types and Classes

2.2.2 Classes
-------------

LibTMCG consists of several C++ classes.  Some of them are only
extensions or optimizations, but other provide necessary interfaces to
perform the basic operations in secure card games, e.g., the creation of
open cards, the masking of cards, the opening of masked cards, the
verifiable secret shuffle of a stack, and more general tasks like
distributed key generation procedures.  Each class implements the main
functionality of the corresponding research
paper [Sc98,BS03,Gr05,HSSV09].  The author names are a prefix of the
class name and the then following part is an abbreviation of the title.

2.2.2.1 Verifiable K-out-of-K Threshold Masking Function
........................................................

The two classes of this subsection are concrete instantiations of
Barnett and Smart's VTMF primitive [BS03].  More formally, the authors
specify four different protocols:
   * Key Generation Protocol
   * Verifiable Masking Protocol
   * Verifiable Re-masking Protocol
   * Verifiable Decryption Protocol
   Each protocol uses low-level operations on an appropriately chosen
algebraic group G.  The choice of this group is crucial to the security
of the card encoding scheme and thus to the high-level operations on
cards resp.  stacks.

   There are just a few methods and members of these classes that might
be of general interest for an application programmer, e.g.  the methods
of the key generation protocol.  The other stuff is only used internally
by high-level operations of 'SchindelhauerTMCG'.  Therefore this manual
omits the description of such internal functions and members.

 -- Class: BarnettSmartVTMF_dlog
     This class implements the discrete logarithm instantiation of the
     VTMF	primitive in the field {\bf Z}/p{\bf Z}, where p is a large
     prime number.  The mathematical computations are performed in the
     finite cyclic	subgroup G of prime order q such that p = kq + 1
     holds	for some k\in {\bf Z}.  The security relies on the DDH
     assumption in	G, i.e., the distribution \{g^a, g^b, g^{ab}\} is
     computationally	indistinguishable from \{g^a, g^b, g^c\}, where g
     is a	generator of G and a, b, c are chosen at random from	{\bf
     Z}_q.  Currently, this well-established assumption is believed to
     hold, if p and q are chosen according to the predefined security
     parameters of LibTMCG.

      -- Member of BarnettSmartVTMF_dlog: mpz_t p
          This is the public prime number p which defines the	underlying
          field {\bf Z}/p{\bf Z}.

      -- Member of BarnettSmartVTMF_dlog: mpz_t q
          This is the public prime number q which defines the	underlying
          cyclic group G.  G is a subgroup of	{\bf Z}/p{\bf Z} and is
          exactly of order q.

      -- Member of BarnettSmartVTMF_dlog: mpz_t g
          This is the fixed public generator g of the underlying	group
          G.

      -- Member of BarnettSmartVTMF_dlog: mpz_t k
          This is a public integer k such that p = kq + 1 holds.

      -- Member of BarnettSmartVTMF_dlog: mpz_t h
          This is the common public key h = \prod_{i=1}^k h_i which
          contains	the public keys h_i of each player P_i.  Note that in
          the	above formula k denotes the number of players.

      -- Constructor on BarnettSmartVTMF_dlog: BarnettSmartVTMF_dlog
               ('unsigned long int' fieldsize '=TMCG_DDH_SIZE',
               'unsigned long int' subgroupsize '=TMCG_DLSE_SIZE')
          This constructor creates a new VTMF instance.  That means, the
          primes	p and q are randomly and uniformly chosen such that
          they have length FIELDSIZE bit and SUBGROUPSIZE bit,
          respectively. 	Further, a generator g for the unique subgroup
          of order q is	chosen at random.  If the arguments are omitted,
          then FIELDSIZE and	SUBGROUPSIZE are set to their default
          values 'TMCG_DDH_SIZE' and	'TMCG_DLSE_SIZE', respectively.
          Depending on FIELDSIZE and SUBGROUPSIZE the group generation
          is a very time-consuming task and some dots are sent to
          'std::cerr' as	a progress indicator.

      -- Constructor on BarnettSmartVTMF_dlog: BarnettSmartVTMF_dlog
               ('std::istream&' in, 'unsigned long int' fieldsize
               '=TMCG_DDH_SIZE', 'unsigned long int' subgroupsize
               '=TMCG_DLSE_SIZE')
          This constructor initializes the VTMF instance from a
          correctly formatted	input stream IN.  For example, such a
          stream can be generated by calling	the method 'PublishGroup'
          of an already created instance.  The arguments	FIELDSIZE and
          SUBGROUPSIZE are stored for later following usage,	e.g.  by
          the method 'CheckGroup' as explained below. 	If these
          arguments are omitted, then they are set to the default values
          'TMCG_DDH_SIZE' and 'TMCG_DLSE_SIZE', respectively.

      -- Method on BarnettSmartVTMF_dlog: bool CheckGroup ()
          This method checks whether p and q have appropriate sizes	with
          respect to the bit lengths given during the initialization of
          the	corresponding instance.  Further, it checks whether p has
          the correct	form (i.e.  p = kq +1), whether p and q are
          probable	prime, and whether g is a generator of the subgroup
          G.  It	returns 'true', if all of these checks have been passed
          successfully.

      -- Method on BarnettSmartVTMF_dlog: void PublishGroup
               ('std::ostream&' out)
          This method exports all necessary group parameters of G to	the
          given output stream OUT, so other VTMF instances of G	can be
          initialized, e.g.  with the second constructor of
          'BarnettSmartVTMF_dlog'.

      -- Method on BarnettSmartVTMF_dlog: void
               KeyGenerationProtocol_GenerateKey ()
          This method generates a VTMF key pair and stores the pair
          internally for	a later following usage.  It must be called
          before any other part	of the key generation protocol is
          executed.  Otherwise, the produced results	are wrong.

      -- Method on BarnettSmartVTMF_dlog: void
               KeyGenerationProtocol_PublishKey ('std::ostream&' out)
          This method exports the public part of the generated VTMF key
          pair to the	given output stream OUT.  Further, it appends a
          non-interactive	zero-knowledge proof of knowledge which shows
          that the instance knows the	secret part. 	Due to the
          non-interactive nature of this proof the method has to be
          called	only once while the computed output can be reused
          multiple times if necessary.

      -- Method on BarnettSmartVTMF_dlog: bool
               KeyGenerationProtocol_UpdateKey ('std::istream&' in)
          This method reads the public part of a VTMF key and the proof
          of knowledge	from the input stream IN.  It appends the key to
          the common public key	and returns 'true', if the given proof
          was sound.  Otherwise, 'false'	is returned.

      -- Method on BarnettSmartVTMF_dlog: bool
               KeyGenerationProtocol_RemoveKey ('std::istream&' in)
          This method reads the public part of a VTMF key and the
          corresponding proof	of knowledge from the input stream IN.  It
          removes the key from the	common public key and returns 'true',
          if the key was previously appended	by
          'KeyGenerationProtocol_UpdateKey' as explained above.

      -- Method on BarnettSmartVTMF_dlog: void
               KeyGenerationProtocol_Finalize ()
          This method must be called after any update
          ('KeyGenerationProtocol_UpdateKey') or removal
          ('KeyGenerationProtocol_RemoveKey') has been performed	on the
          common public key.

      -- Destructor on BarnettSmartVTMF_dlog: ~BarnettSmartVTMF_dlog ()
          This destructor releases all occupied resources.

 -- Subclass of 'BarnettSmartVTMF_dlog': BarnettSmartVTMF_dlog_GroupQR
     This subclass implements the discrete logarithm instantiation of
     the VTMF	primitive in the field {\bf Z}/p{\bf Z}, where p is a
     large	prime number.  The mathematical computations are performed in
     the finite	cyclic subgroup G (quadratic residues modulo p) of prime
     order	q, where p = 2q + 1 holds.  The security relies on the DDH
     assumption in G, i.e., the distribution \{g^a, g^b, g^{ab}\}	is
     computationally indistinguishable from \{g^a, g^b, g^c\}, where	g
     is a generator of G and a, b, c are chosen at random	from {\bf
     Z}_q.  Currently, this well-established assumption is believed	to
     hold, if p and q are chosen according to the predefined	security
     parameters of LibTMCG.

      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t p
          This is the public prime number p which defines the	underlying
          field {\bf Z}/p{\bf Z}.

      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t q
          This is the public prime number q which defines the	underlying
          cyclic group G.  G denotes the unique	subgroup of quadratic
          residues modulo p which is	exactly of order q, if p = 2q + 1
          holds.

      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t g
          This is the fixed public generator g of the underlying	group
          G.

      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t k
          This integer is fixed here by k = 2.

      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t h
          This is the common public key h = \prod_{i=1}^k h_i which
          contains	the public keys h_i of each player P_i.  Note that in
          the	above formula k denotes the number of players.

      -- on BarnettSmartVTMF_dlog_GroupQR: BarnettSmartVTMF_dlog_GroupQR
               ('unsigned long int' fieldsize '=TMCG_DDH_SIZE',
               'unsigned long int' exponentsize '=TMCG_DLSE_SIZE')
          This constructor creates a new VTMF instance.  That means, the
          safe prime	p is randomly and uniformly chosen such that it has
          a length of	FIELDSIZE bit. 	Further, the generator g is
          initially set up by 2 and then	shifted by FIELDSIZE -
          EXPONENTSIZE bit positions,	according to the procedure
          described by Koshiba and Kurosawa (see	_Short Exponent
          Diffie-Hellman Problems_, PKC 2004, LNCS 2947). 	If the
          arguments of the constructor are omitted, then FIELDSIZE and
          EXPONENTSIZE are set to their default values 'TMCG_DDH_SIZE'
          and	'TMCG_DLSE_SIZE', respectively. 	Depending on FIELDSIZE
          and EXPONENTSIZE the group generation	is a very time-consuming
          task and some dots are sent to 'std::cerr' as	a progress
          indicator.

      -- on BarnettSmartVTMF_dlog_GroupQR: BarnettSmartVTMF_dlog_GroupQR
               ('std::istream&' in, 'unsigned long int' fieldsize
               '=TMCG_DDH_SIZE', 'unsigned long int' exponentsize
               '=TMCG_DLSE_SIZE')
          This constructor initializes the VTMF instance from a
          correctly formatted	input stream IN.  For example, such a
          stream can be generated by calling	the method 'PublishGroup'
          of an already created instance.  The arguments	FIELDSIZE and
          EXPONENTSIZE are stored for later following usage,	e.g.  by
          the method 'CheckGroup' as explained below. 	If these
          arguments are omitted, then they are set to the default values
          'TMCG_DDH_SIZE' and 'TMCG_DLSE_SIZE', respectively.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool CheckGroup ()
          This method checks whether p and q have appropriate sizes	with
          respect to the bit lengths given during the initialization of
          the	corresponding instance.  Further, it checks whether p has
          the correct	form (i.e.  p = 2q +1), whether p and q are
          probable	prime, and whether g is a generator of the subgroup
          G.  It	returns 'true', if all of these checks have been passed
          successfully.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: void PublishGroup
               ('std::ostream&' out)
          This method exports all necessary group parameters of G to	the
          given output stream OUT, so other VTMF instances of G	can be
          initialized, e.g.  with the second constructor of
          'BarnettSmartVTMF_dlog_GroupQR'.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
               KeyGenerationProtocol_GenerateKey ()
          This method generates a VTMF key pair and stores the pair
          internally for	a later following usage.  It must be called
          before any other part	of the key generation protocol is
          executed.  Otherwise, the produced results	are wrong.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
               KeyGenerationProtocol_PublishKey ('std::ostream&' out)
          This method exports the public part of the generated VTMF key
          pair to the	given output stream OUT.  Further, it appends a
          non-interactive	zero-knowledge proof of knowledge which shows
          that the instance knows the	secret part. 	Due to the
          non-interactive nature of this proof the method has to be
          called	only once while the computed output can be reused
          multiple times if necessary.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool
               KeyGenerationProtocol_UpdateKey ('std::istream&' in)
          This method reads the public part of a VTMF key and the proof
          of knowledge	from the input stream IN.  It appends the key to
          the common public key	and returns 'true', if the given proof
          was sound.  Otherwise, 'false'	is returned.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool
               KeyGenerationProtocol_RemoveKey ('std::istream&' in)
          This method reads the public part of a VTMF key and the
          corresponding proof	of knowledge from the input stream IN.  It
          removes the key from the	common public key and returns 'true',
          if the key was previously appended	by
          'KeyGenerationProtocol_UpdateKey' as explained above.

      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
               KeyGenerationProtocol_Finalize ()
          This method must be called after any update
          ('KeyGenerationProtocol_UpdateKey') or removal
          ('KeyGenerationProtocol_RemoveKey') has been performed	on the
          common public key.

      -- on BarnettSmartVTMF_dlog_GroupQR:
               ~BarnettSmartVTMF_dlog_GroupQR ()
          This destructor releases all occupied resources.

2.2.2.2 Verifiable Secret Shuffle of Homomorphic Encryptions
............................................................

Recently, Groth [Gr05] has proposed a very efficient solution to perform
a verifiable shuffle of homomorphically encrypted values.  He describes
an honest verifier zero-knowledge argument which shows the correctness
of a shuffle.  Beside other applications (e.g.  verifiable mix networks,
electronic voting) his protocol can be used to show (with overwhelming
probability) that the secret shuffle of a deck of cards was performed
correctly.  The computational complexity and the produced communication
traffic are superior to previously deployed techniques (e.g.
Schindelhauer's cut-and-choose method).  LibTMCG provides the first
known implementation of Groth's famous protocol.  However, it can only
be used along with the VTMF card encoding scheme of Barnett and
Smart [BS03].

   Our implementation uses the statistically hiding and computationally
binding homomorphic commitment scheme due to Pedersen (see
_Non-interactive and Information-theoretic Secure Verifiable Secret
Sharing_, CRYPTO '91, LNCS 576).  The binding property relies on the
hardness of computing discrete logarithms in G, and thus a commitment is
only binding for computationally bounded provers.(1)  But this choice
seems to be reasonable for the intention of LibTMCG, because all players
are supposed to be computationally bounded.  The security parameters of
the commitment scheme (in particular the group G) are determined by the
corresponding VTMF instance.

   Further, to the best of our knowledge it is not known, whether
Groth's protocol retains the zero-knowledge property when it is executed
in a concurrent setting.  Thus the application programmer should be
careful and avoid parallel invocations of the same instance.

 -- Class: GrothVSSHE
     This class provides the low-level interface for Groth's protocol.
     There are just a few methods that might be of general interest.
     All other components are only used internally by high-level
     operations	and thus their description is omitted here.

      -- Constructor on GrothVSSHE: GrothVSSHE ('size_t' n, 'mpz_srcptr'
               p_ENC, 'mpz_srcptr' q_ENC, 'mpz_srcptr' k_ENC,
               'mpz_srcptr' g_ENC, 'mpz_srcptr' h_ENC, 'unsigned long
               int' ell_e '=TMCG_GROTH_L_E', 'unsigned long int'
               fieldsize '=TMCG_DDH_SIZE', 'unsigned long int'
               subgroupsize '=TMCG_DLSE_SIZE')
          This constructor creates a new instance.  The low-level
          operations	are later used to show the correctness of a shuffle
          of at most	N cards.  The protocol and some parameters of the
          commitment	scheme are initialized by the members of the
          corresponding VTMF	instance.  Consequently, P_ENC is the prime
          number p	which determines the field {\bf Z}/p{\bf Z}, Q_ENC	is
          the order of the underlying subgroup G, i.e.  the prime	number
          q, and K_ENC is the integer such that	p = qk + 1 holds.
          Further, G_ENC is the generator	g, and finally H_ENC is the
          common public key h. 	The positive integer ELL_E is the
          security parameter which	controls the soundness error
          probability (2^{-\ell_e}) of	the protocol.  The default value
          is defined by	'TMCG_GROTH_L_E', if this argument is omitted.
          The FIELDSIZE	and the SUBGROUPSIZE are supplied to internal
          classes	and are only of interest, if P_ENC or Q_ENC have
          lengths different from the default.  If these arguments are
          omitted, they are set to 'TMCG_DDH_SIZE' and 'TMCG_DLSE_SIZE',
          respectively.

          Note that the generators g'_1, \ldots, g'_n of the Pedersen
          commitment scheme are randomly and uniformly chosen from {\bf
          Z}_q. 	Therefore this constructor should be instantiated only
          once by the session	leader.  All other instances must be
          created by the second constructor. 	Further, it is very
          important that the VTMF key generation protocol	has been
          finished before the value of h is passed to the	constructor.
          Otherwise, the correctness verification will definitely fail.

      -- Constructor on GrothVSSHE: GrothVSSHE ('size_t' n,
               'std::istream&' in, 'unsigned long int' ell_e
               '=TMCG_GROTH_L_E', 'unsigned long int' fieldsize
               '=TMCG_DDH_SIZE', 'unsigned long int' subgroupsize
               '=TMCG_DLSE_SIZE')
          This constructor initializes the instance from a correctly
          formatted	input stream IN.  For example, such a stream can be
          generated by	calling the method 'PublishGroup' of an already
          created instance. 	Later the instance can be used to show the
          correctness of a shuffle of	at most N cards. 	The positive
          integer ELL_E controls the soundness error probability	of the
          protocol.  The default value is defined by 'TMCG_GROTH_L_E',
          if this argument is omitted.

      -- Method on GrothVSSHE: bool CheckGroup ()
          This method checks whether the initialized commitment scheme
          is sound. 	It returns 'true', if all tests have been passed
          successfully.

      -- Method on GrothVSSHE: void PublishGroup ('std::ostream&' out)
          This method exports the instance configuration to the output
          stream	OUT such that other instances can be initialized, e.g.
          with the	second constructor.

      -- Destructor on GrothVSSHE: ~GrothVSSHE ()
          This destructor releases all occupied resources.

2.2.2.3 Verifiable Rotation of Homomorphic Encryptions
......................................................

Hoogh, Schoenmakers, Skoric, and Villegas [HSSV09] has proposed an
efficient solution to perform a verifiable rotation (also known as
cyclic shift) of homomorphically encrypted values.  Other solutions
(e.g.  Reiter and Wang, _Fragile Mixing_, ACM CCS, 2004) does not
provide that level of efficency.  LibTMCG provides the first known
implementation of their protocol.  It can only be used with the VTMF
card encoding scheme of Barnett and Smart [BS03].

   Further, to the best of our knowledge it is not known, whether their
protocol retains the zero-knowledge property when it is executed in a
concurrent setting.  Thus the application programmer should be careful
and avoid parallel invocations of the same instance.

 -- Class: HooghSchoenmakersSkoricVillegasVRHE
     This class provides the low-level interface for their protocol.
     There are just a few methods that might be of general interest.
     All other components are only used internally by high-level
     operations	and thus their description is omitted here.

      -- Constructor on HooghSchoenmakersSkoricVillegasVRHE:
               HooghSchoenmakersSkoricVillegasVRHE ('mpz_srcptr' p_ENC,
               'mpz_srcptr' q_ENC, 'mpz_srcptr' k_ENC, 'mpz_srcptr'
               g_ENC, 'mpz_srcptr' h_ENC, 'unsigned long int' fieldsize
               '=TMCG_DDH_SIZE', 'unsigned long int' subgroupsize
               '=TMCG_DLSE_SIZE')
          This constructor creates a new instance.  The low-level
          operations	are later used to show the correctness of a
          rotation of the cards. 	The protocol and some of its
          parameters are initialized by the	members of the corresponding
          VTMF instance.  Consequently, P_ENC	is the prime number p
          which determines the field	{\bf Z}/p{\bf Z}, Q_ENC is the
          order of the underlying	subgroup G, i.e.  the prime number q,
          and K_ENC is	the integer such that p = qk + 1 holds.  Further,
          G_ENC is	the generator g, and finally H_ENC is the common
          public	key h. 	The FIELDSIZE and the SUBGROUPSIZE are supplied
          to internal	classes and are only of interest, if P_ENC or
          Q_ENC have	lengths different from the default.  If these
          arguments are omitted,	they are set to 'TMCG_DDH_SIZE' and
          'TMCG_DLSE_SIZE', respectively.

          This constructor should be instantiated only once by the
          session	leader.  All other instances must be created by the
          second constructor. 	Further, it is very important that the
          VTMF key generation protocol	has been finished before the
          value of h is passed to the	constructor.  Otherwise, the
          correctness verification will definitely fail.

      -- Constructor on HooghSchoenmakersSkoricVillegasVRHE:
               HooghSchoenmakersSkoricVillegasVRHE ('std::istream&' in,
               'unsigned long int' fieldsize '=TMCG_DDH_SIZE', 'unsigned
               long int' subgroupsize '=TMCG_DLSE_SIZE')
          This constructor initializes the instance from a correctly
          formatted	input stream IN.  For example, such a stream can be
          generated by	calling the method 'PublishGroup' of an already
          created instance. 	Later the instance can be used to show the
          correctness of a rotation.

      -- Method on HooghSchoenmakersSkoricVillegasVRHE: bool CheckGroup
               ()
          This method checks whether the initialized commitment scheme
          is sound. 	It returns 'true', if all tests have been passed
          successfully.

      -- Method on HooghSchoenmakersSkoricVillegasVRHE: void
               PublishGroup ('std::ostream&' out)
          This method exports the instance configuration to the output
          stream	OUT such that other instances can be initialized, e.g.
          with the	second constructor.

      -- Destructor on HooghSchoenmakersSkoricVillegasVRHE:
               ~HooghSchoenmakersSkoricVillegasVRHE ()
          This destructor releases all occupied resources.

2.2.2.4 Toolbox for Mental Card Games
.....................................

This section explains the main class of LibTMCG which provides all
"high-level operations" from Schindelhauer's toolbox [Sc98].  Even if
the more efficient card encoding scheme of Barnett and Smart [BS03] is
deployed, at least one instance of the following class must be created
to perform any card or stack operations.

 -- Class: SchindelhauerTMCG
     This class implements the main core of Schindelhauer's toolbox,
     i.e.  important functions like masking, opening, and shuffling of
     cards and stacks, respectively.  Some exotic operations are still
     missing,	e.g., the possibility to insert a masked card secretly
     into a stack or	the verifiable subset properties of stacks. 	All
     implemented operations are available for the original encoding
     scheme	of Schindelhauer (see 'TMCG_Card') and, of course, for the
     more efficient	encoding scheme of Barnett and Smart (see
     'VTMF_Card' and	'BarnettSmartVTMF_dlog') as well.

      -- Member of SchindelhauerTMCG: unsigned long int
               TMCG_SecurityLevel
          This read-only nonnegative integer represents the security
          parameter t	which was given to the constructor of this class.
          It defines the number of	protocol iterations and hence the
          soundness error probability (2^{-t})	of the zero-knowledge
          proofs in the encoding scheme of Schindelhauer. 	Further it
          defines the soundness error probability (also 2^{-t})	of the
          shuffle argument in the encoding scheme of Barnett and Smart,
          if	the efficient protocol of Groth [Gr05] is not used.

      -- Member of SchindelhauerTMCG: size_t TMCG_Players
          This read-only nonnegative integer represents the number of
          players as	given to the constructor of this class.

      -- Member of SchindelhauerTMCG: size_t TMCG_TypeBits
          This read-only nonnegative integer contains the number of bits
          that are	necessary to encode the card types in the binary
          representation.  It was	given as an argument to the
          constructor of this class.

      -- Constructor on SchindelhauerTMCG: SchindelhauerTMCG ('unsigned
               long int' security, 'size_t' k, 'size_t' w)
          This constructor creates an instance, where SECURITY is a
          nonnegative	integer that represents the security parameter t.
          The parameter K	is the number of players and W is the number
          of bits which are necessary	to represent all possible card
          types in a binary representation.

          The integer t controls the maximum soundness error probability
          (2^{-t})	of the zero-knowledge proofs in the encoding scheme
          of Schindelhauer. 	Specifically, SECURITY defines the number
          of sequential iterations of	the involved protocols and thus
          has a major impact on the computational	and communication
          complexity.  If the encoding scheme of Barnett and
          Smart [BS03] is used, then it only defines the soundness error
          probability (also 2^{-t}) of the shuffle proof.  However, if
          only	the efficient shuffle verification protocol of
          Groth [Gr05] is used,	then the parameter SECURITY is
          dispensable, because the parameter ELL_E	given during
          instantiation of 'GrothVSSHE' (e.g.  the LibTMCG default
          security	parameter 'TMCG_GROTH_L_E') determines this soundness
          error probability	(2^{-\ell_e}).

          Unfortunately, the parameters K and W have a major impact on
          the	complexity in the encoding scheme of Schindelhauer, too.
          Therefore you should always use	reasonable values.  For
          example, to create a deck with M different card types	simply
          set W to \lceil\log_2 M\rceil which is an tight upper-bound
          for	the binary representation.  Furthermore, set K to the
          number of players which are really involved and not to a
          possible maximum value. 	Note that K and W are limited by the
          global constants	'TMCG_MAX_PLAYERS' and 'TMCG_MAX_TYPEBITS',
          respectively.

      -- Method on SchindelhauerTMCG: void TMCG_CreateOpenCard
               ('TMCG_Card&' c, 'const TMCG_PublicKeyRing&' ring,
               'size_t' type)
          This method initializes the open card C with the given TYPE
          using the encoding scheme of Schindelhauer.  The TYPE MUST be
          an	integer from the interval [0, 2^{w} - 1], where w is the
          number given to the constructor of this class.  The w MUST be
          the	same number as used at creation of C (see 'TMCG_Card').
          The	parameter RING is a container with exactly k public keys,
          where k is the number given to the constructor of this class.
          The k MUST be the same number as used at the creation of C.

      -- Method on SchindelhauerTMCG: void TMCG_CreateOpenCard
               ('VTMF_Card&' c, 'BarnettSmartVTMF_dlog*' vtmf, 'size_t'
               type)
          This method initializes the open card C with the given TYPE
          using the encoding scheme of Barnett and Smart.  The TYPE MUST
          be an	integer from the interval [0, 2^{w} - 1], where w is the
          number given to the constructor of this class.  The parameter
          VTMF	is a pointer to an already initialized VTMF instance,
          i.e.  the key	generation protocol was successfully finished
          (see 'BarnettSmartVTMF_dlog'	and
          'BarnettSmartVTMF_dlog_GroupQR', respectively).

      -- Method on SchindelhauerTMCG: void TMCG_CreateCardSecret
               ('TMCG_CardSecret&' cs, 'const TMCG_PublicKeyRing&' ring,
               'size_t' index)
          This method initializes the card secret CS with random values
          which is necessary to perform later a masking operation on a
          card. 	The parameter RING is a container with exactly k public
          keys, where k is the number given to the constructor of this
          class.  It MUST be the same number as used at the creation of
          CS	(see 'TMCG_CardSecret').  The parameter INDEX is from the
          interval [0, k - 1] and determines the position of the players
          public key in the container RING.

      -- Method on SchindelhauerTMCG: void TMCG_CreateCardSecret
               ('VTMF_CardSecret&' cs, 'BarnettSmartVTMF_dlog*' vtmf)
          This method initializes the card secret CS with a random value
          which is necessary to perform later a masking operation on a
          card. 	The parameter VTMF is a pointer to an already
          initialized VTMF	instance, i.e.  the key generation protocol
          MUST be successfully finished	(see 'BarnettSmartVTMF_dlog' and
          'BarnettSmartVTMF_dlog_GroupQR',	respectively).

      -- Method on SchindelhauerTMCG: void TMCG_CreatePrivateCard
               ('TMCG_Card&' c, 'TMCG_CardSecret&' cs, 'const
               TMCG_PublicKeyRing&' ring, 'size_t' index, 'size_t' type)
          This method initializes a masked card C with the given TYPE
          and	a corresponding card secret CS using the encoding scheme
          of	Schindelhauer. 	The TYPE MUST be an integer from the
          interval [0, 2^{w} - 1],	where w is the number given to the
          constructor of this class.  The	w MUST be the same number as
          used at creation of C (see	'TMCG_Card') and CS (see
          'TMCG_CardSecret').  The parameter	RING is a container with
          exactly k public keys, where k	is the number given to the
          constructor of this class.  The k MUST be	the same number as
          used at the creation of C and CS.  The parameter	INDEX is from
          the interval [0, k - 1] and determines the	position of the
          players public key in the container RING. 	Internally,
          'TMCG_CreatePrivateCard' calls
            1. 'TMCG_CreateOpenCard' to initialize C with TYPE,
            2. 'TMCG_CreateCardSecret' to initialize CS with random
               values, and
            3. 'TMCG_MaskCard' to mask C with the secret CS.

      -- Method on SchindelhauerTMCG: void TMCG_CreatePrivateCard
               ('VTMF_Card&' c, 'VTMF_CardSecret&' cs,
               'BarnettSmartVTMF_dlog*' vtmf, 'size_t' type)
          This method initializes a masked card C with the given TYPE
          and	a corresponding card secret CS using the encoding scheme
          of Barnett and	Smart.  The TYPE MUST be an integer from the
          interval	[0, 2^{w} - 1], where w is the number given to the
          constructor	of this class.  The parameter VTMF is a pointer to
          an already initialized	VTMF instance, i.e.  the key generation
          protocol MUST be successfully finished	(see
          'BarnettSmartVTMF_dlog' and 'BarnettSmartVTMF_dlog_GroupQR',
          respectively).  Specifically, 'TMCG_CreatePrivateCard'
          directly executes	the masking operation of the verifiable
          masking protocol.

      -- Method on SchindelhauerTMCG: void TMCG_MaskCard ('const
               TMCG_Card&' c, 'TMCG_Card&' cc, 'const TMCG_CardSecret&'
               cs, 'const TMCG_PublicKeyRing&' ring, 'bool'
               TimingAttackProtection '=true')
          This method performs a masking operation on the open or
          already masked card	C using the encoding scheme of
          Schindelhauer.  Finally it returns the	result in CC. 	The
          parameter CS MUST be an initialized fresh card secret which
          has NEVER	been involved in a masking operation before.  The
          parameters C, CC,	and CS MUST be created such that their k and
          w	corresponds to the numbers given to the constructor of this
          class,	respectively.  The parameter RING is a container with
          exactly	k public keys. 	The protection against timing attacks
          is turned on, if	TIMINGATTACKPROTECTION is set to 'true'.

      -- Method on SchindelhauerTMCG: void TMCG_MaskCard ('const
               VTMF_Card&' c, 'VTMF_Card&' cc, 'const VTMF_CardSecret&'
               cs, 'BarnettSmartVTMF_dlog*' vtmf, 'bool'
               TimingAttackProtection '=true')
          This method performs a masking operation on the open or
          already masked card	C using the encoding scheme of Barnett and
          Smart.  Finally it returns the	result in CC.  Specifically,
          'TMCG_MaskCard' directly executes	the masking operation of the
          verifiable re-masking protocol. 	The parameter CS MUST be an
          initialized fresh card secret which has	NEVER been involved in
          a masking operation before. 	The parameter VTMF is a pointer
          to an already initialized	VTMF instance, i.e.  the key
          generation protocol MUST be successfully finished	(see
          'BarnettSmartVTMF_dlog' and 'BarnettSmartVTMF_dlog_GroupQR',
          respectively).  The protection against timing attacks is
          turned on, if	TIMINGATTACKPROTECTION is set to 'true'.

      -- Method on SchindelhauerTMCG: void TMCG_ProveMaskCard ('const
               TMCG_Card&' c, 'const TMCG_Card&' cc, 'const
               TMCG_CardSecret&' cs, 'const TMCG_PublicKeyRing&' ring,
               'std::istream&' in, 'std::ostream&' out)
          This method should be called by the prover after
          'TMCG_MaskCard' to show	that he performed the masking
          operation correctly.  The parameters C,	CC, and CS are the
          input, the result, and the used card secret	of
          'TMCG_MaskCard', respectively. 	They MUST be created such that
          their k resp.  w	corresponds to the numbers given to the
          constructor of this class.  The	parameter RING is a container
          with exactly k public keys. 	The input/output protocol
          messages from and to the verifier are	transmitted on the
          streams IN and OUT, respectively.

      -- Method on SchindelhauerTMCG: void TMCG_ProveMaskCard ('const
               VTMF_Card&' c, 'const VTMF_Card&' cc, 'const
               VTMF_CardSecret&' cs, 'BarnettSmartVTMF_dlog*' vtmf,
               'std::istream&' in, 'std::ostream&' out)
          This method should be executed by the prover after calling
          'TMCG_MaskCard'	to show that he performed the masking
          operation correctly.  Specifically,	'TMCG_ProveMaskCard'
          directly calls the prove operation of the	verifiable
          re-masking protocol. 	The parameters C, CC, and CS are the
          input, the result, and	the used card secret of
          'TMCG_MaskCard', respectively. 	The parameter VTMF is a
          pointer to an already initialized VTMF instance,	i.e.  the key
          generation protocol MUST be successfully finished. 	The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyMaskCard ('const
               TMCG_Card&' c, 'const TMCG_Card&' cc, 'const
               TMCG_PublicKeyRing&' ring, 'std::istream&' in,
               'std::ostream&' out)
          This method should be executed by the verifier to check
          whether or not a	masking operation was performed correctly.
          The parameters C and	CC are the input and the result of
          'TMCG_MaskCard', respectively. 	They MUST be created such that
          their k resp.  w corresponds to	the numbers given to the
          constructor of this class. 	The parameter RING is a container
          with exactly k public keys. 	The input/output protocol
          messages from and to the prover are	transmitted on the streams
          IN and OUT, respectively. 	The method returns 'true', if
          everything was sound.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyMaskCard ('const
               VTMF_Card&' c, 'const VTMF_Card&' cc,
               'BarnettSmartVTMF_dlog*' vtmf, 'std::istream&' in,
               'std::ostream&' out)
          This method should be executed by the verifier to check
          whether or not a	masking operation was performed correctly.
          Specifically,	'TMCG_VerifyMaskCard' directly calls the verify
          operation of the	verifiable re-masking protocol.  The
          parameters C and	CC are the input and the result of
          'TMCG_MaskCard', respectively. 	The parameter VTMF is a
          pointer to an already initialized VTMF instance,	i.e.  the key
          generation protocol MUST be successfully finished. 	The
          input/output protocol messages from and to the prover are
          transmitted on the streams IN and OUT, respectively. 	The
          method returns 'true', if everything was sound.

      -- Method on SchindelhauerTMCG: void TMCG_ProveCardSecret ('const
               TMCG_Card&' c, 'const TMCG_SecretKey&' key, 'size_t'
               index, 'std::istream&' in, 'std::ostream&' out)
          This method is used to reveal the card type of C to a
          verifier. 	Every player must execute this method as prover.
          The card C MUST be created such that its k resp.  w
          corresponds to the numbers given to the constructor of this
          class. 	The parameter KEY is the corresponding secret key (see
          'TMCG_SecretKey') of the prover.  The parameter INDEX is from
          the	interval [0, k - 1] and contains the position of the
          provers	public key in the container RING (same as in
          'TMCG_CreateCardSecret'). 	The input/output protocol messages
          from and to the verifier are	transmitted on the streams IN and
          OUT, respectively.

      -- Method on SchindelhauerTMCG: void TMCG_ProveCardSecret ('const
               VTMF_Card&' c, 'BarnettSmartVTMF_dlog*' vtmf,
               'std::istream&' in, 'std::ostream&' out)
          This method is used to reveal the card type of C to a
          verifier. 	Every player must execute this method as prover.
          Specifically, 'TMCG_ProveCardSecret' directly calls the prove
          operation of the	verifiable decryption protocol. 	The
          parameter VTMF is a pointer to an already initialized VTMF
          instance,	i.e.  the key generation protocol MUST be
          successfully finished. 	The input/output protocol messages
          from and to the verifier are	transmitted on the streams IN and
          OUT, respectively.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyCardSecret ('const
               TMCG_Card&' c, 'TMCG_CardSecret&' cs, 'const
               TMCG_PublicKey&' key, 'size_t' index, 'std::istream&' in,
               'std::ostream&' out)
          This method is used to verify and accumulate card type
          information regarding	C that are supplied by a prover.  It is
          the opposite method of	'TMCG_ProveCardSecret' and must be
          executed by the player who wants to	know the type.  The
          secrets provided by the single provers are accumulated in	the
          parameter CS. 	Thus C and CS MUST be created such that their k
          resp.  w	corresponds to the numbers given to the constructor
          of this class. 	The parameter KEY is the corresponding public
          key (see 'TMCG_PublicKey')	of the prover.  The parameter INDEX
          is from the interval [0, k - 1]	and contains the position of
          the provers public key in the container RING	(same as in
          'TMCG_CreateCardSecret'). 	The input/output protocol messages
          from and to the prover are	transmitted on the streams IN and
          OUT, respectively.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyCardSecret ('const
               VTMF_Card&' c, 'BarnettSmartVTMF_dlog*' vtmf,
               'std::istream&' in, 'std::ostream&' out)
          This method is used to verify and accumulate card type
          information regarding	C that are supplied by a prover.  It is
          the opposite method of	'TMCG_ProveCardSecret' and must be
          executed by the player who wants	to know the type.  The
          secrets provided by the single provers are accumulated
          internally, thus this method cannot be interleaved with the
          opening of other	cards. 	Specifically, 'TMCG_VerifyCardSecret'
          directly calls the verify	and update operation of the
          verifiable decryption protocol. 	The parameter VTMF is a
          pointer to an already initialized VTMF instance,	i.e.  the key
          generation protocol MUST be successfully finished. 	The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.

      -- Method on SchindelhauerTMCG: void TMCG_SelfCardSecret ('const
               TMCG_Card&' c, 'TMCG_CardSecret&' cs, 'const
               TMCG_SecretKey&' key, 'size_t' index)
          This method is used to compute and accumulate card type
          information regarding	C.  Analogously to
          'TMCG_VerifyCardSecret' it must be executed by the	player who
          wants to know the type of C.  The information is accumulated
          in	the parameter CS. 	Thus C and CS MUST be created such that
          their k resp.  w	corresponds to the numbers given to the
          constructor of this class. 	The parameter KEY is the
          corresponding secret key (see 'TMCG_SecretKey')	of the player.
          The parameter INDEX is from the interval [0, k - 1]	and
          contains the position of the players public key in the
          container RING	(same as in 'TMCG_CreateCardSecret').

      -- Method on SchindelhauerTMCG: void TMCG_SelfCardSecret ('const
               VTMF_Card&' c, 'BarnettSmartVTMF_dlog*' vtmf)
          This method is used to compute and accumulate card type
          information regarding	C.  It MUST be called by the player who
          wants to know the type of C	BEFORE 'TMCG_VerifyCardSecret' and
          'TMCG_TypeOfCard' are executed. 	The secrets provided by the
          player are accumulated internally, thus this method	cannot be
          interleaved with the opening of other cards. 	Specifically,
          'TMCG_SelfCardSecret' directly calls the initialize operation
          of the verifiable decryption protocol. 	The parameter VTMF is
          a pointer to an already initialized VTMF instance,	i.e.  the
          key generation protocol MUST be successfully finished.

      -- Method on SchindelhauerTMCG: size_t TMCG_TypeOfCard ('const
               TMCG_CardSecret&' cs)
          This method returns the type of a masked card provided that
          the type	information were properly accumulated in CS before
          (by calling	'TMCG_SelfCardSecret' and 'TMCG_VerifyCardSecret',
          respectively).

      -- Method on SchindelhauerTMCG: size_t TMCG_TypeOfCard ('const
               VTMF_Card&' c, 'BarnettSmartVTMF_dlog*' vtmf)
          This method returns the type of a masked card C provided that
          the type	information regarding C were properly accumulated
          internally before (by calling	'TMCG_SelfCardSecret' and
          'TMCG_VerifyCardSecret', respectively). 	It returns the value
          'TMCG_MaxCardType', if the opening operation	failed or if the
          card type was not among the set of valid types. 	This method
          MUST be performed by the player who wants to know the type
          AFTER	'TMCG_SelfCardSecret' and 'TMCG_VerifyCardSecret' are
          executed. 	Specifically, 'TMCG_TypeOfCard' directly calls the
          finalize operation	of the verifiable decryption protocol. 	The
          parameter VTMF is a pointer to an already initialized VTMF
          instance,	i.e.  the key generation protocol MUST be
          successfully finished.

      -- Method on SchindelhauerTMCG: size_t TMCG_CreateStackSecret
               ('TMCG_StackSecret<TMCG_CardSecret>&' ss, 'bool' cyclic,
               'const TMCG_PublicKeyRing&' ring, 'size_t' index,
               'size_t' size)
          This method initializes the stack secret SS with a randomly
          and	uniformly chosen permutation (using the algorithm of
          Knuth) and fresh card secrets.  Later this stack	secret can be
          used to perform a secret shuffle operation on a stack. 	If the
          parameter CYCLIC is set to 'true', then the permutation	is
          only a cyclic shift which might be of interest for particular
          operations, e.g.  cutting the deck. 	The parameter RING is a
          container with exactly k public	keys, where k is the number
          given to the constructor of this	class.  The parameter INDEX
          is from the interval [0, k - 1]	and contains the position of
          the players public key in the container	RING.  The parameter
          SIZE determines the size of the created	stack secret, i.e.
          the number of cards in the corresponding stack.  The	SIZE is
          upper-bounded by 'TMCG_MAX_CARDS'. 	The method returns the
          offset of the cyclic shift, if CYCLIC was set	to 'true'.
          Otherwise, the value '0' is returned.

      -- Method on SchindelhauerTMCG: size_t TMCG_CreateStackSecret
               ('TMCG_StackSecret<VTMF_CardSecret>&' ss, 'bool' cyclic,
               'size_t' size, 'BarnettSmartVTMF_dlog*' vtmf)
          This method initializes the stack secret SS with a randomly
          and	uniformly chosen permutation (using the algorithm of
          Knuth) and fresh	card secrets.  Later this stack	secret can be
          used to perform a secret shuffle operation on a stack. 	If the
          parameter CYCLIC is set to 'true', then the permutation	is
          only a cyclic shift which might be of interest for particular
          operations, e.g.  cutting the deck. 	The parameter SIZE
          determines the size of the created	stack secret, i.e.  the
          number of cards in the corresponding stack.  The	SIZE is
          upper-bounded by 'TMCG_MAX_CARDS'. 	The parameter VTMF is a
          pointer to an already initialized VTMF instance,	i.e.  the key
          generation protocol MUST be successfully finished. 	The method
          returns the offset of the cyclic shift, if CYCLIC was set	to
          'true'.  Otherwise, the value '0' is returned.

      -- Method on SchindelhauerTMCG: void TMCG_MixStack ('const
               TMCG_Stack<TMCG_Card>&' s, 'TMCG_Stack<TMCG_Card>&' s2,
               'const TMCG_StackSecret<TMCG_CardSecret>&' ss, 'const
               TMCG_PublicKeyRing&' ring, 'bool' TimingAttackProtection
               '=true')
          This method shuffles a given stack S according to the
          previously	created stack secret SS (see
          'TMCG_CreateStackSecret').  The	result of the shuffle is
          returned in S2. 	The parameter SS MUST be a fresh stack secret
          which has NEVER	been involved in a shuffle operation before.
          The parameters S	and SS MUST be of the same size.  The
          parameter RING is a	container with exactly k public keys,
          where k is the	number given to the constructor of this class.
          The protection against timing attacks is turned on, if
          TIMINGATTACKPROTECTION is set to 'true'.

      -- Method on SchindelhauerTMCG: void TMCG_MixStack ('const
               TMCG_Stack<VTMF_Card>&' s, 'TMCG_Stack<VTMF_Card>&' s2,
               'const TMCG_StackSecret<VTMF_CardSecret>&' ss,
               'BarnettSmartVTMF_dlog*' vtmf, 'bool'
               TimingAttackProtection '=true')
          This method shuffles a given stack S according to the
          previously	created stack secret SS (see
          'TMCG_CreateStackSecret').  The	result of the shuffle is
          returned in S2. 	The parameter SS MUST be a fresh stack secret
          which has NEVER	been involved in a shuffle operation before.
          The parameters S	and SS MUST be of the same size. 	The
          parameter VTMF is a pointer to an already initialized VTMF
          instance,	i.e.  the key generation protocol MUST be
          successfully finished. 	The protection against timing attacks
          is turned on, if	TIMINGATTACKPROTECTION is set to 'true'.

      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality
               ('const TMCG_Stack<TMCG_Card>&' s, 'const
               TMCG_Stack<TMCG_Card>&' s2, 'const
               TMCG_StackSecret<TMCG_CardSecret>&' ss, 'bool' cyclic,
               'const TMCG_PublicKeyRing&' ring, 'size_t' index,
               'std::istream&' in, 'std::ostream&' out)
          This method should be called by the prover after
          'TMCG_MixStack' to show	that he performed the shuffle
          operation correctly.  The parameters S,	S2, and SS are the
          input, the result, and the used stack secret	of
          'TMCG_MixStack', respectively. 	Of course, the parameters S,
          S2, and SS MUST be of the same size. 	The parameter CYCLIC
          determines whether a cyclic shift or a full permutation	was
          used to shuffle the stack. 	The parameter RING is a container
          with exactly k public keys, where	k is the number given to the
          constructor of this class. 	The parameter INDEX is from the
          interval [0, k - 1] and contains the	position of the provers
          public key in the container RING. 	The input/output protocol
          messages from and to the verifier are	transmitted on the
          streams IN and OUT, respectively.

      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality
               ('const TMCG_Stack<VTMF_Card>&' s, 'const
               TMCG_Stack<VTMF_Card>&' s2, 'const
               TMCG_StackSecret<VTMF_CardSecret>&' ss, 'bool' cyclic,
               'BarnettSmartVTMF_dlog*' vtmf, 'std::istream&' in,
               'std::ostream&' out)
          This method should be called by the prover after
          'TMCG_MixStack' to show	that he performed the shuffle
          operation correctly.  The parameters S,	S2, and SS are the
          input, the result, and the used stack secret	of
          'TMCG_MixStack', respectively. 	Of course, the parameters S,
          S2, and SS MUST be of the same size. 	The parameter CYCLIC
          determines whether a cyclic shift or a full permutation	was
          used to shuffle the stack. 	The parameter VTMF is a pointer to
          an already initialized VTMF instance,	i.e.  the key generation
          protocol MUST be successfully finished. 	The input/output
          protocol messages from and to the verifier are	transmitted on
          the streams IN and OUT, respectively.

      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality_Groth
               ('const TMCG_Stack<VTMF_Card>&' s, 'const
               TMCG_Stack<VTMF_Card>&' s2, 'const
               TMCG_StackSecret<VTMF_CardSecret>&' ss,
               'BarnettSmartVTMF_dlog*' vtmf, 'GrothVSSHE*' vsshe,
               'std::istream&' in, 'std::ostream&' out)
          This is a method like above.  The only difference is that the
          more	efficient shuffle verification protocol of Groth is used.
          Thus VSSHE	is a pointer to an initialized instance of
          'GrothVSSHE'. 	The rest of the arguments are the same.

      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality_Hoogh
               ('const TMCG_Stack<VTMF_Card>&' s, 'const
               TMCG_Stack<VTMF_Card>&' s2, 'const
               TMCG_StackSecret<VTMF_CardSecret>&' ss,
               'BarnettSmartVTMF_dlog*' vtmf,
               'HooghSchoenmakersSkoricVillegasVRHE*' vrhe,
               'std::istream&' in, 'std::ostream&' out)
          This is a method like above.  The only difference is that the
          more	efficient rotation verification protocol [HSSV09] is
          used.  Thus VRHE	is a pointer to an initialized instance of
          'HooghSchoenmakersSkoricVillegasVRHE'. 	The rest of the
          arguments are the same.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyStackEquality
               ('const TMCG_Stack<TMCG_Card>&' s, 'const
               TMCG_Stack<TMCG_Card>&' s2, 'bool' cyclic, 'const
               TMCG_PublicKeyRing&' ring, 'std::istream&' in,
               'std::ostream&' out)
          This method should be executed by the verifier to check
          whether or not a	shuffle operation was performed correctly.
          The parameters S and	S2 are the input and the result of
          'TMCG_MixStack', respectively. 	Of course, the parameters S
          and S2 should be of the same size. 	The parameter CYCLIC
          determines whether a cyclic shift or a full permutation	was
          used to shuffle the stack. 	The parameter RING is a container
          with exactly k public keys, where	k is the number given to the
          constructor of this class. 	The input/output protocol messages
          from and to the prover are	transmitted on the streams IN and
          OUT, respectively. 	This method returns 'true', if the shuffle
          operation was successfully verified.

      -- Method on SchindelhauerTMCG: bool TMCG_VerifyStackEquality
               ('const TMCG_Stack<VTMF_Card>&' s, 'const
               TMCG_Stack<VTMF_Card>&' s2, 'bool' cyclic,
               'BarnettSmartVTMF_dlog*' vtmf, 'std::istream&' in,
               'std::ostream&' out)
          This method should be executed by the verifier to check
          whether or not a	shuffle operation was performed correctly.
          The parameters S and	S2 are the input and the result of
          'TMCG_MixStack', respectively. 	Of course, the parameters S
          and S2 should be of the same size. 	The parameter CYCLIC
          determines whether a cyclic shift or a full permutation	was
          used to shuffle the stack. 	The parameter VTMF is a pointer to
          an already initialized VTMF instance,	i.e.  the key generation
          protocol MUST be successfully finished. 	The input/output
          protocol messages from and to the verifier are	transmitted on
          the streams IN and OUT, respectively. 	This method returns
          'true', if the shuffle operation was successfully verified.

      -- Method on SchindelhauerTMCG: bool
               TMCG_VerifyStackEquality_Groth ('const
               TMCG_Stack<VTMF_Card>&' s, 'const TMCG_Stack<VTMF_Card>&'
               s2, 'BarnettSmartVTMF_dlog*' vtmf, 'GrothVSSHE*' vsshe,
               'std::istream&' in, 'std::ostream&' out)
          This is a method like above.  The only difference is that the
          more	efficient shuffle verification protocol of Groth is used.
          Thus VSSHE	is a pointer to an initialized instance of
          'GrothVSSHE'. 	The rest of the arguments and the returned
          values are the same.

      -- Method on SchindelhauerTMCG: bool
               TMCG_VerifyStackEquality_Hoogh ('const
               TMCG_Stack<VTMF_Card>&' s, 'const TMCG_Stack<VTMF_Card>&'
               s2, 'BarnettSmartVTMF_dlog*' vtmf,
               'HooghSchoenmakersSkoricVillegasVRHE*' vrhe,
               'std::istream&' in, 'std::ostream&' out)
          This is a method like above.  The only difference is that the
          more	efficient rotation verification protocol [HSSV09] is
          used.  Thus VRHE	is a pointer to an initialized instance of
          'HooghSchoenmakersSkoricVillegasVRHE'. 	The rest of the
          arguments and the returned values are the same.

      -- Destructor on SchindelhauerTMCG: ~SchindelhauerTMCG ()
          This destructor releases all occupied resources.

   ---------- Footnotes ----------

   (1) Strictly speaking, due to this reason Groth's protocol is a
zero-knowledge _argument_ instead of a zero-knowledge _proof_.  However,
for convenience we will not distinguish between these terms here.


File: libTMCG.info,  Node: Examples,  Next: Licenses,  Prev: Application Programming Interface,  Up: Top

3 Examples
**********

The following examples explain most of the steps that are necessary to
create a secure and fair card game with LibTMCG. We consider an
application with five permanent players (denoted by P_0, P_1, P_2, P_3,
and P_4) and a regular deck of 52 different cards.  For convenience only
the more efficient card encoding scheme of Barnett and Smart [BS03] is
described.  Additionally, we complete our exposition with code fragments
which show the usage of the fast shuffle verification protocol due to
Groth [Gr05].

   Throughout the remaining pages we suppose that all players are
pairwise connected by authenticated communication channels.  These
channels are organized in input resp.  output streams, where
'input_stream[i]' resp.  'output_stream[i]' denote the corresponding
'std::istream' resp.  'std::ostream' instance for the communication with
player P_i.(1)

* Menu:

* Library Initialization::
* Session Initialization and Key Generation::
* Operations on Cards::
* Operations on Stacks::
* Quit a Session::

   ---------- Footnotes ----------

   (1) We assume that the players are ordered in a natural way such that
we can use the same nomenclature.


File: libTMCG.info,  Node: Library Initialization,  Next: Session Initialization and Key Generation,  Up: Examples

3.1 Library Initialization
==========================

The very first step that should be performed is the initialization of
LibTMCG. That can simply be done by calling the function 'init_libTMCG'
and evaluating the return code.
     if (!init_libTMCG())
       std::cerr << "Initialization of LibTMCG failed!" << std::endl;
   Additionally, in the most cases it is useful to check the installed
library version by using the function 'version_libTMCG'.


File: libTMCG.info,  Node: Session Initialization and Key Generation,  Next: Operations on Cards,  Prev: Library Initialization,  Up: Examples

3.2 Session Initialization and Key Generation
=============================================

In the next step we create an instance of the class 'SchindelhauerTMCG'.
The first parameter determines the number of protocol iterations t which
upper-bounds the cheating probability by 2^{-t}.  In our example the
used value '64' defines a maximum cheating probability of
5.421010862\cdot 10^{-20} which is reasonable small for our purposes.
The second parameter passes the number of players to the instance which
is simply '5' in our case.  The last argument defines the number of bits
that are necessary to encode all card types in a binary representation.
The given value '6' allows the encoding of 2^6 = 64 different card types
at maximum.  This is enough to form our deck of 52 cards.
     SchindelhauerTMCG *tmcg = new SchindelhauerTMCG(64, 5, 6);
   We would like to use the more efficient encoding scheme of Barnett
and Smart, thus we create an instance of 'BarnettSmartVTMF_dlog'.
However, a particular player has to act as a _leader_ who performs the
generation of the group G.  In our case P_0 will be the session leader.
First, he executes the constructor of 'BarnettSmartVTMF_dlog'.
     BarnettSmartVTMF_dlog *vtmf = new BarnettSmartVTMF_dlog();
   Afterwards he checks the generated group G and sends the public
parameters to all other players (corresponding stream indices are '1',
'2', '3', and '4', respectively).
     if (!vtmf->CheckGroup())
       std::cerr << "Group G was not correctly generated!" << std::endl;
     for (size_t i = 1; i < 5; i++)
       vtmf->PublishGroup(output_stream[i]);
   The other players receive the group parameters from P_0 and use them
to initialize their corresponding instances of 'BarnettSmartVTMF_dlog'.
It is very important that they also check, whether the group G was
correctly generated by the leader.
     BarnettSmartVTMF_dlog *vtmf =
       new BarnettSmartVTMF_dlog(input_stream[0]);
     if (!vtmf->CheckGroup())
       std::cerr << "Group G was not correctly generated!" << std::endl;
   Afterwards the key generation protocol is carried out.  First, every
player generates his own VTMF key.  The secret key material is stored
internally and will never be exposed.
     vtmf->KeyGenerationProtocol_GenerateKey();
   Then every player P_j sends the public part of his VTMF key along
with a non-interactive zero-knowledge proof of knowledge to each other
player.  The appended proof shows that he indeed knows the corresponding
secret key.  However, due to the non-interactive nature of this proof we
have to be careful, if same group G is used again.
     for (size_t i = 0; i < 5; i++)
     {
       if (i != j)
         vtmf->KeyGenerationProtocol_PublishKey(output_stream[i]);
     }
   After sending P_j receives the public keys.  Simultaneously he
checks, whether the keys are correctly generated, and updates the common
public key h.
     for (size_t i = 0; i < 5; i++)
     {
       if (i != j)
       {
         if (!vtmf->KeyGenerationProtocol_UpdateKey(input_stream[i]))
           std::cerr << "Public key was not correctly generated!" << std::endl;
       }
     }
   Finally, every player must finalize the key generation protocol.
     vtmf->KeyGenerationProtocol_Finalize();
   If we want to use the more efficient shuffle verification protocol of
Groth, then P_0 must also create an instance of 'GrothVSSHE'.  The first
argument determines the maximum stack size of which the correctness of a
shuffle will be proven.  The other parameters are obtained from the
former created VTMF instance 'vtmf'.  It is important that the key
generation protocol has been finalized before the common public key h
(i.e.  'vtmf->h') is passed.
     GrothVSSHE *vsshe = new GrothVSSHE(52, vtmf->p, vtmf->q, vtmf->k,
       vtmf->g, vtmf->h);
   Again, P_0 will send the public parameters of the VSSHE instance to
all other players.
     for (size_t i = 1; i < 5; i++)
       vsshe->PublishGroup(output_stream[i]);
   The other players receive these parameters from the leader and use
them to initialize their corresponding instances of 'GrothVSSHE'.
Again, it is important to check, whether the parameters were correctly
chosen by the leader.
     GrothVSSHE *vsshe = new GrothVSSHE(52, input_stream[0]);
     if (!vsshe->CheckGroup())
       std::cerr << "VSSHE was not correctly generated!" << std::endl;
     if (mpz_cmp(vtmf->h, vsshe->com->h))
       std::cerr << "VSSHE: Common public key does not match!" << std::endl;
     if (mpz_cmp(vtmf->q, vsshe->com->q))
       std::cerr << "VSSHE: Subgroup order does not match!" << std::endl;
     if (mpz_cmp(vtmf->p, vsshe->p) || mpz_cmp(vtmf->q, vsshe->q) ||
       mpz_cmp(vtmf->g, vsshe->g) || mpz_cmp(vtmf->h, vsshe->h))
         std::cerr << "VSSHE: Encryption scheme does not match!" << std::endl;


File: libTMCG.info,  Node: Operations on Cards,  Next: Operations on Stacks,  Prev: Session Initialization and Key Generation,  Up: Examples

3.3 Operations on Cards
=======================

Now we are ready to perform several operations on cards.  We start with
some basic stuff which might be of interest in particular situations.
However, it is often more convenient to work directly with stacks, as
explained later.

* Menu:

* Creating an Open Card::
* Masking and Re-masking of a Card::
* Opening a Masked Card::


File: libTMCG.info,  Node: Creating an Open Card,  Next: Masking and Re-masking of a Card,  Up: Operations on Cards

3.3.1 Creating an Open Card
---------------------------

The creation of an open card is very simple.  The following code creates
a card of type '7'.
     VTMF_Card c;
     tmcg->TMCG_CreateOpenCard(c, vtmf, 7);


File: libTMCG.info,  Node: Masking and Re-masking of a Card,  Next: Opening a Masked Card,  Prev: Creating an Open Card,  Up: Operations on Cards

3.3.2 Masking and Re-masking of a Card
--------------------------------------

Now the previously created card 'c' will be masked to hide its type.
Then 'cc' is sent to P_1.
     VTMF_Card cc;
     VTMF_CardSecret cs;
     tmcg->TMCG_CreateCardSecret(cs, vtmf);
     tmcg->TMCG_MaskCard(c, cc, cs, vtmf);
     out_stream[1] << cc << std::endl;
   P_1 receives the card 'cc', re-masks them, and sends the result 'ccc'
back to the player P_0.  Further he proves that the masking operation
was performed correctly.
     VTMF_Card cc, ccc;
     VTMF_CardSecret ccs;
     in_stream[0] >> cc;
     if (!in_stream[0].good())
       std::cerr << "Read or parse error!" << std::endl;
     tmcg->TMCG_CreateCardSecret(ccs, vtmf);
     tmcg->TMCG_MaskCard(cc, ccc, ccs, vtmf);
     out_stream[0] << ccc << std::endl;
     tmcg->TMCG_ProveMaskCard(cc, ccc, ccs, vtmf, in_stream[0], out_stream[0]);
   P_0 receives the card, verifies the proof, and sends the card to all
other players.
     VTMF_Card ccc;
     in_stream[1] >> ccc;
     if (!tmcg->TMCG_VerifyMaskCard(cc, ccc, vtmf, in_stream[1], out_stream[1]))
       std::cerr << "Verification failed!" << std::endl;
     for (size_t i = 1; i < 5; i++)
       out_stream[i] << ccc << std::endl;
   Finally, all other players receive and store the masked card 'ccc'.


File: libTMCG.info,  Node: Opening a Masked Card,  Prev: Masking and Re-masking of a Card,  Up: Operations on Cards

3.3.3 Opening a Masked Card
---------------------------

Suppose that P_1 would like to know the type of the masked card 'ccc'.
Of course, P_0 could simply reveal it, but that isn't verifiable.
Anyway, if all players cooperate, then P_1 can compute the type in a
verifiable way.  First, every player (except P_1) will execute the
following code.
     tmcg->TMCG_ProveCardSecret(ccc, vtmf, in_stream[1], out_stream[1]);
   On the other hand, P_1 will execute the following commands exactly in
the given order.  Finally, he obtain the card type in the variable
'type'.
     tmcg->TMCG_SelfCardSecret(ccc, vtmf);
     for (size_t i = 0; i < 5; i++)
     {
       if (i == 1)
         continue;
       if (!tmcg->TMCG_VerifyCardSecret(ccc, vtmf, in_stream[i], out_stream[i]))
         std::cerr << "Verification failed!" << std::endl;
     }
     type = tmcg->TMCG_TypeOfCard(ccc, vtmf);


File: libTMCG.info,  Node: Operations on Stacks,  Next: Quit a Session,  Prev: Operations on Cards,  Up: Examples

3.4 Operations on Stacks
========================

There exist a lot of basic operations on stacks, e.g.  pushing a card to
a stack or importing a stack.  These functions are to simple for
explaining them here, but they are used implicitly.  However, a short
description can be found in the API part of the manual (see 'TMCG_Stack'
and 'TMCG_OpenStack').

* Menu:

* Creating the Deck::
* Shuffling the Deck::
* Drawing a Card from the Deck::


File: libTMCG.info,  Node: Creating the Deck,  Next: Shuffling the Deck,  Up: Operations on Stacks

3.4.1 Creating the Deck
-----------------------

A quite common operation is the creation of a card deck.  The deck will
initially be represented by an open stack (see 'TMCG_OpenStack') called
'deck'.  Every player creates his own deck which consists of
52 different open cards in our example.
     TMCG_OpenStack<VTMF_Card> deck;
     for (size_t type = 0; type < 52; type++)
     {
       VTMF_Card c;
       tmcg->TMCG_CreateOpenCard(c, vtmf, type);
       deck.push(type, c);
     }
   Note that this card deck must be consistent for all players, that
means, the order of the open cards must be exactly the same for all
players.


File: libTMCG.info,  Node: Shuffling the Deck,  Next: Drawing a Card from the Deck,  Prev: Creating the Deck,  Up: Operations on Stacks

3.4.2 Shuffling the Deck
------------------------

Each player must perform a shuffle of the deck, because only such a
procedure guarantees that no coalition has influence on the outcome.
Thus we build a shuffle chain such that every player shuffles the deck.
Consider the following code fragment for the player P_j.

   The regular stack 's' is initialized with open cards from 'deck'.
Then each player shuffles the stack (see 'TMCG_MixStack') and proves the
correctness of this operation (see 'TMCG_ProveStackEquality').
Consequently, every player should verify these proofs (see
'TMCG_VerifyStackEquality').  Finally, the stack 's' contains the
shuffled result.
     TMCG_Stack<VTMF_Card> s;
     s.push(deck);

     for (size_t i = 0; i < 5; i++)
     {
       TMCG_Stack<VTMF_Card> s2;
       if (i == j)
       {
         TMCG_StackSecret<VTMF_CardSecret> ss;
         tmcg->TMCG_CreateStackSecret(ss, false, s.size(), vtmf);
         tmcg->TMCG_MixStack(s, s2, ss, vtmf);
         for (size_t i2 = 0; i2 < 5; i2++)
         {
           if (i2 == j)
             continue;
           out_stream[i2] << s2 << std::endl;
           tmcg->TMCG_ProveStackEquality(s, s2, ss, false, vtmf,
             in_stream[i2], out_stream[i2]);
         }
       }
       else
       {
         in_stream[i] >> s2;
         if (!in_stream[i].good())
           std::cerr << "Read or parse error!" << std::endl;
         if (!tmcg->TMCG_VerifyStackEquality(s, s2, false, vtmf,
           in_stream[i], out_stream[i]))
             std::cerr << "Verification failed!" << std::endl;
       }
       s = s2;
     }

   If you want to use the more efficient shuffle verification protocol
of Groth, then you must simply replace 'TMCG_ProveStackEquality' and
'TMCG_VerifyStackEquality' by 'TMCG_ProveStackEquality_Groth' and
'TMCG_VerifyStackEquality_Groth', respectively.


File: libTMCG.info,  Node: Drawing a Card from the Deck,  Prev: Shuffling the Deck,  Up: Operations on Stacks

3.4.3 Drawing a Card from the Deck
----------------------------------

Now every player has the same shuffled deck 's' and nobody knows in
which order the 52 cards are stacked.  Therefore you can simply use any
drawing strategy to obtain a players hand.  For example, look at the
following code that draws two cards from 's' for each player.
     TMCG_Stack<VTMF_Card> hand[5];
     for (size_t i = 0; i < 5; i++)
     {
       VTMF_Card c1, c2;
       s.pop(c1), s.pop(c2);
       hand[i].push(c1), hand[i].push(c2);
     }
   Further, probably you want disclose the card types to the
corresponding player.  Consider the code fragment for the player P_j:
Every player receives the necessary information from the other players
and computes the card types of his hand 'hand[j]'.  Finally, these types
are stored together with the masked cards in the open stack
'private_hand'.  The example can be modified in a straightforward way to
publicly disclose a card from a players hand or from the remaining stack
's'.
     TMCG_OpenStack<VTMF_Card> private_hand;
     for (size_t i = 0; i < 5; i++)
     {
       if (i == j)
       {
         for (size_t k = 0; k < hand[j].size(); k++)
         {
           tmcg->TMCG_SelfCardSecret(hand[j][k], vtmf);
           for (size_t i2 = 0; i2 < 5; i2++)
           {
             if (i2 == j)
               continue;
             if (!tmcg->TMCG_VerifyCardSecret(hand[j][k], vtmf,
               in_stream[i2], out_stream[i2]))
                 std::cerr << "Verification failed!" << std::endl;
           }
           private_hand.push(tmcg->TMCG_TypeOfCard(hand[j][k], vtmf),
             hand[j][k]);
         }
       }
       else
       {
         for (size_t k = 0; k < hand[i].size(); k++)
         {
           tmcg->TMCG_ProveCardSecret(hand[i][k], vtmf,
             in_stream[i], out_stream[i]);
         }
       }
     }


File: libTMCG.info,  Node: Quit a Session,  Prev: Operations on Stacks,  Up: Examples

3.5 Quit a Session
==================

The last step should release all occupied resources.
     delete vsshe, delete vtmf, delete tmcg;


File: libTMCG.info,  Node: Licenses,  Next: General and API Index,  Prev: Examples,  Up: Top

Appendix A Licenses
*******************

A.1 GNU General Public License
==============================

                         Version 2, June 1991

     Copyright © 1989, 1991 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom to
share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users.  This General Public
License applies to most of the Free Software Foundation's software and
to any other program whose authors commit to using it.  (Some other Free
Software Foundation software is covered by the GNU Lesser General Public
License instead.)  You can apply it to your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it if
you want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on the
     Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's source
     code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion of
     it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program or
          any part thereof, to be licensed as a whole at no charge to
          all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not apply
     to those sections when you distribute them as separate works.  But
     when you distribute the same sections as part of a whole which is a
     work based on the Program, the distribution of the whole must be on
     the terms of this License, whose permissions for other licensees
     extend to the entire whole, and thus to each and every part
     regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on a
     volume of a storage or distribution medium does not bring the other
     work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either source
     or binary form) with the major components (compiler, kernel, and so
     on) of the operating system on which the executable runs, unless
     that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this License
     to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program subject
     to these terms and conditions.  You may not impose any further
     restrictions on the recipients' exercise of the rights granted
     herein.  You are not responsible for enforcing compliance by third
     parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who receive
     copies directly or indirectly through you, then the only way you
     could satisfy both it and this License would be to refrain entirely
     from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies to
     it and "any later version", you have the option of following the
     terms and conditions either of that version or of any later version
     published by the Free Software Foundation.  If the Program does not
     specify a version number of this License, you may choose any
     version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted by
     the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                              NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
     AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
     OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
     PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE
     DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
     OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YYYY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands 'show w' and 'show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than 'show w' and 'show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.

A.2 GNU Free Documentation License
==================================

                      Version 1.2, November 2002

     Copyright © 2000,2001,2002 Free Software Foundation, Inc.
     51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: libTMCG.info,  Node: General and API Index,  Prev: Licenses,  Up: Top

Appendix B General and API Index
********************************

General Index
=============

 [index ]
* Menu:

* Card:                                  Terminology.         (line  14)
* Card Encoding Schemes:                 Data Types.          (line  12)
* Card Secret:                           Terminology.         (line  27)
* Card Type:                             Terminology.         (line  17)
* Classes:                               Classes.             (line   6)
* Data Types:                            Data Types.          (line   6)
* Examples:                              Examples.            (line   6)
* FDL, GNU Free Documentation License:   Licenses.            (line 366)
* GPL, GNU General Public License:       Licenses.            (line   9)
* Header Files:                          Header Files and Name Spaces.
                                                              (line   6)
* Initialization:                        Initializing the Library.
                                                              (line   6)
* Initialization <1>:                    Library Initialization.
                                                              (line   6)
* Initialization <2>:                    Session Initialization and Key Generation.
                                                              (line   6)
* Key Generation:                        Session Initialization and Key Generation.
                                                              (line   6)
* Keys:                                  Data Types.          (line 582)
* Masked Card:                           Terminology.         (line  36)
* Masking:                               Terminology.         (line  21)
* Name Spaces:                           Header Files and Name Spaces.
                                                              (line   6)
* Observer:                              Terminology.         (line  12)
* Open Card:                             Terminology.         (line  33)
* Player:                                Terminology.         (line   9)
* Private Card:                          Terminology.         (line  41)
* Prover:                                Terminology.         (line  49)
* Security:                              Security.            (line   6)
* Security Advice:                       Security.            (line  64)
* Security Parameters:                   Preprocessor Defined Global Symbols.
                                                              (line   6)
* Stack:                                 Terminology.         (line  46)
* Stacks:                                Data Types.          (line 289)
* Terminology:                           Terminology.         (line   6)
* Verifier:                              Terminology.         (line  49)

API Index
=========

 [index ]
* Menu:

* != on TMCG_Card:                       Data Types.         (line   72)
* != on TMCG_OpenStack:                  Data Types.         (line  425)
* != on TMCG_Stack:                      Data Types.         (line  325)
* != on VTMF_Card:                       Data Types.         (line  203)
* << on TMCG_Card:                       Data Types.         (line   90)
* << on TMCG_CardSecret:                 Data Types.         (line  160)
* << on TMCG_PublicKey:                  Data Types.         (line  871)
* << on TMCG_SecretKey:                  Data Types.         (line  747)
* << on TMCG_Stack:                      Data Types.         (line  388)
* << on TMCG_StackSecret:                Data Types.         (line  568)
* << on VTMF_Card:                       Data Types.         (line  214)
* << on VTMF_CardSecret:                 Data Types.         (line  274)
* = on TMCG_Card:                        Data Types.         (line   65)
* = on TMCG_CardSecret:                  Data Types.         (line  140)
* = on TMCG_OpenStack:                   Data Types.         (line  414)
* = on TMCG_PublicKey:                   Data Types.         (line  811)
* = on TMCG_SecretKey:                   Data Types.         (line  676)
* = on TMCG_Stack:                       Data Types.         (line  314)
* = on TMCG_StackSecret:                 Data Types.         (line  517)
* = on VTMF_Card:                        Data Types.         (line  196)
* = on VTMF_CardSecret:                  Data Types.         (line  261)
* == on TMCG_Card:                       Data Types.         (line   69)
* == on TMCG_OpenStack:                  Data Types.         (line  419)
* == on TMCG_Stack:                      Data Types.         (line  319)
* == on VTMF_Card:                       Data Types.         (line  200)
* >> on TMCG_Card:                       Data Types.         (line   95)
* >> on TMCG_CardSecret:                 Data Types.         (line  165)
* >> on TMCG_PublicKey:                  Data Types.         (line  875)
* >> on TMCG_SecretKey:                  Data Types.         (line  751)
* >> on TMCG_Stack:                      Data Types.         (line  392)
* >> on TMCG_StackSecret:                Data Types.         (line  573)
* >> on VTMF_Card:                       Data Types.         (line  219)
* >> on VTMF_CardSecret:                 Data Types.         (line  279)
* [] on TMCG_OpenStack:                  Data Types.         (line  431)
* [] on TMCG_OpenStack <1>:              Data Types.         (line  437)
* [] on TMCG_Stack:                      Data Types.         (line  331)
* [] on TMCG_Stack <1>:                  Data Types.         (line  336)
* [] on TMCG_StackSecret:                Data Types.         (line  522)
* [] on TMCG_StackSecret <1>:            Data Types.         (line  528)
* ~BarnettSmartVTMF_dlog on BarnettSmartVTMF_dlog: Classes.  (line  153)
* ~BarnettSmartVTMF_dlog_GroupQR on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  276)
* ~GrothVSSHE on GrothVSSHE:             Classes.            (line  376)
* ~HooghSchoenmakersSkoricVillegasVRHE on HooghSchoenmakersSkoricVillegasVRHE: Classes.
                                                             (line  451)
* ~SchindelhauerTMCG on SchindelhauerTMCG: Classes.          (line 1015)
* ~TMCG_Card on TMCG_Card:               Data Types.         (line   87)
* ~TMCG_CardSecret on TMCG_CardSecret:   Data Types.         (line  157)
* ~TMCG_OpenStack on TMCG_OpenStack:     Data Types.         (line  496)
* ~TMCG_PublicKey on TMCG_PublicKey:     Data Types.         (line  868)
* ~TMCG_PublicKeyRing on TMCG_PublicKeyRing: Data Types.     (line  898)
* ~TMCG_SecretKey on TMCG_SecretKey:     Data Types.         (line  744)
* ~TMCG_Stack on TMCG_Stack:             Data Types.         (line  385)
* ~TMCG_StackSecret on TMCG_StackSecret: Data Types.         (line  565)
* ~VTMF_Card on VTMF_Card:               Data Types.         (line  211)
* ~VTMF_CardSecret on VTMF_CardSecret:   Data Types.         (line  271)
* AM_PATH_LIBTMCG:                       Building Sources.   (line   51)
* BarnettSmartVTMF_dlog:                 Classes.            (line   37)
* BarnettSmartVTMF_dlog on BarnettSmartVTMF_dlog: Classes.   (line   71)
* BarnettSmartVTMF_dlog on BarnettSmartVTMF_dlog <1>: Classes.
                                                             (line   85)
* BarnettSmartVTMF_dlog_GroupQR:         Classes.            (line  156)
* BarnettSmartVTMF_dlog_GroupQR on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  191)
* BarnettSmartVTMF_dlog_GroupQR on BarnettSmartVTMF_dlog_GroupQR <1>: Classes.
                                                             (line  208)
* check on TMCG_PublicKey:               Data Types.         (line  816)
* check on TMCG_SecretKey:               Data Types.         (line  681)
* CheckGroup on BarnettSmartVTMF_dlog:   Classes.            (line   98)
* CheckGroup on BarnettSmartVTMF_dlog_GroupQR: Classes.      (line  221)
* CheckGroup on GrothVSSHE:              Classes.            (line  366)
* CheckGroup on HooghSchoenmakersSkoricVillegasVRHE: Classes.
                                                             (line  439)
* clear on TMCG_OpenStack:               Data Types.         (line  473)
* clear on TMCG_Stack:                   Data Types.         (line  364)
* clear on TMCG_StackSecret:             Data Types.         (line  543)
* decrypt on TMCG_SecretKey:             Data Types.         (line  721)
* empty on TMCG_OpenStack:               Data Types.         (line  463)
* empty on TMCG_Stack:                   Data Types.         (line  356)
* encrypt on TMCG_PublicKey:             Data Types.         (line  856)
* encrypt on TMCG_SecretKey:             Data Types.         (line  732)
* find on TMCG_OpenStack:                Data Types.         (line  476)
* find on TMCG_Stack:                    Data Types.         (line  367)
* find on TMCG_StackSecret:              Data Types.         (line  556)
* find_position on TMCG_StackSecret:     Data Types.         (line  547)
* fingerprint on TMCG_PublicKey:         Data Types.         (line  824)
* fingerprint on TMCG_SecretKey:         Data Types.         (line  689)
* GrothVSSHE:                            Classes.            (line  312)
* GrothVSSHE on GrothVSSHE:              Classes.            (line  318)
* GrothVSSHE on GrothVSSHE <1>:          Classes.            (line  352)
* HooghSchoenmakersSkoricVillegasVRHE:   Classes.            (line  395)
* HooghSchoenmakersSkoricVillegasVRHE on HooghSchoenmakersSkoricVillegasVRHE: Classes.
                                                             (line  401)
* HooghSchoenmakersSkoricVillegasVRHE on HooghSchoenmakersSkoricVillegasVRHE <1>: Classes.
                                                             (line  429)
* import on TMCG_Card:                   Data Types.         (line   82)
* import on TMCG_CardSecret:             Data Types.         (line  152)
* import on TMCG_PublicKey:              Data Types.         (line  852)
* import on TMCG_SecretKey:              Data Types.         (line  717)
* import on TMCG_Stack:                  Data Types.         (line  380)
* import on TMCG_StackSecret:            Data Types.         (line  560)
* import on VTMF_Card:                   Data Types.         (line  206)
* import on VTMF_CardSecret:             Data Types.         (line  266)
* init_libTMCG:                          Initializing the Library.
                                                             (line   10)
* KeyGenerationProtocol_Finalize on BarnettSmartVTMF_dlog: Classes.
                                                             (line  146)
* KeyGenerationProtocol_Finalize on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  269)
* KeyGenerationProtocol_GenerateKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  114)
* KeyGenerationProtocol_GenerateKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  237)
* KeyGenerationProtocol_PublishKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  121)
* KeyGenerationProtocol_PublishKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  244)
* KeyGenerationProtocol_RemoveKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  138)
* KeyGenerationProtocol_RemoveKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  261)
* KeyGenerationProtocol_UpdateKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  131)
* KeyGenerationProtocol_UpdateKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  254)
* keyid on TMCG_PublicKey:               Data Types.         (line  836)
* keyid on TMCG_SecretKey:               Data Types.         (line  701)
* keyid_size on TMCG_PublicKey:          Data Types.         (line  842)
* keyid_size on TMCG_SecretKey:          Data Types.         (line  707)
* move on TMCG_OpenStack:                Data Types.         (line  490)
* pop on TMCG_OpenStack:                 Data Types.         (line  466)
* pop on TMCG_Stack:                     Data Types.         (line  359)
* PublishGroup on BarnettSmartVTMF_dlog: Classes.            (line  107)
* PublishGroup on BarnettSmartVTMF_dlog_GroupQR: Classes.    (line  230)
* PublishGroup on GrothVSSHE:            Classes.            (line  371)
* PublishGroup on HooghSchoenmakersSkoricVillegasVRHE: Classes.
                                                             (line  445)
* push on TMCG_OpenStack:                Data Types.         (line  446)
* push on TMCG_OpenStack <1>:            Data Types.         (line  452)
* push on TMCG_OpenStack <2>:            Data Types.         (line  458)
* push on TMCG_Stack:                    Data Types.         (line  344)
* push on TMCG_Stack <1>:                Data Types.         (line  347)
* push on TMCG_Stack <2>:                Data Types.         (line  351)
* push on TMCG_StackSecret:              Data Types.         (line  537)
* remove on TMCG_OpenStack:              Data Types.         (line  480)
* remove on TMCG_Stack:                  Data Types.         (line  371)
* removeAll on TMCG_OpenStack:           Data Types.         (line  485)
* removeAll on TMCG_Stack:               Data Types.         (line  376)
* resize on TMCG_Card:                   Data Types.         (line   75)
* resize on TMCG_CardSecret:             Data Types.         (line  145)
* SchindelhauerTMCG:                     Classes.            (line  465)
* SchindelhauerTMCG on SchindelhauerTMCG: Classes.           (line  497)
* selfid on TMCG_PublicKey:              Data Types.         (line  830)
* selfid on TMCG_SecretKey:              Data Types.         (line  695)
* sigid on TMCG_PublicKey:               Data Types.         (line  847)
* sigid on TMCG_SecretKey:               Data Types.         (line  712)
* sign on TMCG_SecretKey:                Data Types.         (line  728)
* size on TMCG_OpenStack:                Data Types.         (line  443)
* size on TMCG_Stack:                    Data Types.         (line  341)
* size on TMCG_StackSecret:              Data Types.         (line  534)
* TMCG_Card:                             Data Types.         (line   35)
* TMCG_Card on TMCG_Card:                Data Types.         (line   50)
* TMCG_Card on TMCG_Card <1>:            Data Types.         (line   55)
* TMCG_Card on TMCG_Card <2>:            Data Types.         (line   61)
* TMCG_CardSecret:                       Data Types.         (line  102)
* TMCG_CardSecret on TMCG_CardSecret:    Data Types.         (line  122)
* TMCG_CardSecret on TMCG_CardSecret <1>: Data Types.        (line  128)
* TMCG_CardSecret on TMCG_CardSecret <2>: Data Types.        (line  135)
* TMCG_CreateCardSecret on SchindelhauerTMCG: Classes.       (line  555)
* TMCG_CreateCardSecret on SchindelhauerTMCG <1>: Classes.   (line  567)
* TMCG_CreateOpenCard on SchindelhauerTMCG: Classes.         (line  531)
* TMCG_CreateOpenCard on SchindelhauerTMCG <1>: Classes.     (line  543)
* TMCG_CreatePrivateCard on SchindelhauerTMCG: Classes.      (line  576)
* TMCG_CreatePrivateCard on SchindelhauerTMCG <1>: Classes.  (line  597)
* TMCG_CreateStackSecret on SchindelhauerTMCG: Classes.      (line  821)
* TMCG_CreateStackSecret on SchindelhauerTMCG <1>: Classes.  (line  842)
* TMCG_DDH_SIZE:                         Preprocessor Defined Global Symbols.
                                                             (line   22)
* TMCG_DLSE_SIZE:                        Preprocessor Defined Global Symbols.
                                                             (line   28)
* TMCG_GCRY_MD_ALGO:                     Preprocessor Defined Global Symbols.
                                                             (line   34)
* TMCG_GROTH_L_E:                        Preprocessor Defined Global Symbols.
                                                             (line   15)
* TMCG_HASH_COMMITMENT:                  Preprocessor Defined Global Symbols.
                                                             (line  142)
* TMCG_KEYID_SIZE:                       Preprocessor Defined Global Symbols.
                                                             (line   51)
* TMCG_KEY_NIZK_STAGE1:                  Preprocessor Defined Global Symbols.
                                                             (line   65)
* TMCG_KEY_NIZK_STAGE2:                  Preprocessor Defined Global Symbols.
                                                             (line   73)
* TMCG_KEY_NIZK_STAGE3:                  Preprocessor Defined Global Symbols.
                                                             (line   80)
* TMCG_LIBGCRYPT_VERSION:                Preprocessor Defined Global Symbols.
                                                             (line   87)
* TMCG_LIBGMP_VERSION:                   Preprocessor Defined Global Symbols.
                                                             (line   94)
* TMCG_MaskCard on SchindelhauerTMCG:    Classes.            (line  612)
* TMCG_MaskCard on SchindelhauerTMCG <1>: Classes.           (line  627)
* TMCG_MAX_CARDS:                        Preprocessor Defined Global Symbols.
                                                             (line  102)
* TMCG_MAX_FPOWM_T:                      Preprocessor Defined Global Symbols.
                                                             (line  150)
* TMCG_MAX_PLAYERS:                      Preprocessor Defined Global Symbols.
                                                             (line  106)
* TMCG_MAX_TYPEBITS:                     Preprocessor Defined Global Symbols.
                                                             (line  111)
* TMCG_MixStack on SchindelhauerTMCG:    Classes.            (line  860)
* TMCG_MixStack on SchindelhauerTMCG <1>: Classes.           (line  876)
* TMCG_MPZ_IO_BASE:                      Preprocessor Defined Global Symbols.
                                                             (line  118)
* TMCG_MR_ITERATIONS:                    Preprocessor Defined Global Symbols.
                                                             (line   10)
* TMCG_OpenStack on TMCG_OpenStack:      Data Types.         (line  411)
* TMCG_OpenStack<:                       Data Types.         (line  398)
* TMCG_PRAB_K0:                          Preprocessor Defined Global Symbols.
                                                             (line  124)
* TMCG_ProveCardSecret on SchindelhauerTMCG: Classes.        (line  706)
* TMCG_ProveCardSecret on SchindelhauerTMCG <1>: Classes.    (line  721)
* TMCG_ProveMaskCard on SchindelhauerTMCG: Classes.          (line  644)
* TMCG_ProveMaskCard on SchindelhauerTMCG <1>: Classes.      (line  659)
* TMCG_ProveStackEquality on SchindelhauerTMCG: Classes.     (line  892)
* TMCG_ProveStackEquality on SchindelhauerTMCG <1>: Classes. (line  913)
* TMCG_ProveStackEquality_Groth on SchindelhauerTMCG: Classes.
                                                             (line  932)
* TMCG_ProveStackEquality_Hoogh on SchindelhauerTMCG: Classes.
                                                             (line  943)
* TMCG_PublicKey:                        Data Types.         (line  757)
* TMCG_PublicKey on TMCG_PublicKey:      Data Types.         (line  798)
* TMCG_PublicKey on TMCG_PublicKey <1>:  Data Types.         (line  801)
* TMCG_PublicKey on TMCG_PublicKey <2>:  Data Types.         (line  806)
* TMCG_PublicKeyRing:                    Data Types.         (line  881)
* TMCG_PublicKeyRing on TMCG_PublicKeyRing: Data Types.      (line  890)
* TMCG_PublicKeyRing on TMCG_PublicKeyRing <1>: Data Types.  (line  893)
* TMCG_QRA_SIZE:                         Preprocessor Defined Global Symbols.
                                                             (line  130)
* TMCG_SAEP_S0:                          Preprocessor Defined Global Symbols.
                                                             (line  136)
* TMCG_SecretKey:                        Data Types.         (line  595)
* TMCG_SecretKey on TMCG_SecretKey:      Data Types.         (line  649)
* TMCG_SecretKey on TMCG_SecretKey <1>:  Data Types.         (line  652)
* TMCG_SecretKey on TMCG_SecretKey <2>:  Data Types.         (line  666)
* TMCG_SecretKey on TMCG_SecretKey <3>:  Data Types.         (line  671)
* TMCG_SelfCardSecret on SchindelhauerTMCG: Classes.         (line  770)
* TMCG_SelfCardSecret on SchindelhauerTMCG <1>: Classes.     (line  785)
* TMCG_Stack on TMCG_Stack:              Data Types.         (line  311)
* TMCG_Stack<:                           Data Types.         (line  295)
* TMCG_StackSecret on TMCG_StackSecret:  Data Types.         (line  514)
* TMCG_StackSecret<:                     Data Types.         (line  499)
* TMCG_TypeOfCard on SchindelhauerTMCG:  Classes.            (line  798)
* TMCG_TypeOfCard on SchindelhauerTMCG <1>: Classes.         (line  805)
* TMCG_VerifyCardSecret on SchindelhauerTMCG: Classes.       (line  734)
* TMCG_VerifyCardSecret on SchindelhauerTMCG <1>: Classes.   (line  753)
* TMCG_VerifyMaskCard on SchindelhauerTMCG: Classes.         (line  675)
* TMCG_VerifyMaskCard on SchindelhauerTMCG <1>: Classes.     (line  690)
* TMCG_VerifyStackEquality on SchindelhauerTMCG: Classes.    (line  956)
* TMCG_VerifyStackEquality on SchindelhauerTMCG <1>: Classes.
                                                             (line  974)
* TMCG_VerifyStackEquality_Groth on SchindelhauerTMCG: Classes.
                                                             (line  992)
* TMCG_VerifyStackEquality_Hoogh on SchindelhauerTMCG: Classes.
                                                             (line 1003)
* verify on TMCG_PublicKey:              Data Types.         (line  863)
* verify on TMCG_SecretKey:              Data Types.         (line  739)
* version_libTMCG:                       Initializing the Library.
                                                             (line   21)
* VTMF_Card:                             Data Types.         (line  172)
* VTMF_Card on VTMF_Card:                Data Types.         (line  188)
* VTMF_Card on VTMF_Card <1>:            Data Types.         (line  192)
* VTMF_CardSecret:                       Data Types.         (line  226)
* VTMF_CardSecret on VTMF_CardSecret:    Data Types.         (line  252)
* VTMF_CardSecret on VTMF_CardSecret <1>: Data Types.        (line  256)



Tag Table:
Node: Top623
Node: Introduction1406
Node: Further Reading3607
Node: Getting Started5535
Node: Preliminaries6229
Node: Terminology6759
Node: Security8986
Ref: Security-Footnote-113105
Node: Preparation13206
Node: Header Files and Name Spaces14575
Ref: Header Files and Name Spaces-Footnote-115610
Node: Building Sources15866
Node: Initializing the Library18652
Node: Application Programming Interface19666
Node: Preprocessor Defined Global Symbols19928
Ref: Preprocessor Defined Global Symbols-Footnote-127706
Node: Data Types and Classes27768
Node: Data Types28173
Ref: Data Types-Footnote-170628
Node: Classes70731
Ref: Classes-Footnote-1129053
Node: Examples129260
Ref: Examples-Footnote-1130439
Node: Library Initialization130547
Node: Session Initialization and Key Generation131119
Node: Operations on Cards136078
Node: Creating an Open Card136600
Node: Masking and Re-masking of a Card136932
Node: Opening a Masked Card138388
Node: Operations on Stacks139392
Node: Creating the Deck139953
Node: Shuffling the Deck140689
Node: Drawing a Card from the Deck142686
Node: Quit a Session144674
Node: Licenses144901
Node: General and API Index186430

End Tag Table


Local Variables:
coding: iso-8859-1
End:
